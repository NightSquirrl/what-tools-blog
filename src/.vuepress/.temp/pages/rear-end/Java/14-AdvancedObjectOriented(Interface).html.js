import comp from "/Users/zeroeldath/Desktop/ignore-space/what-tools-blog/src/.vuepress/.temp/pages/rear-end/Java/14-AdvancedObjectOriented(Interface).html.vue"
const data = JSON.parse("{\"path\":\"/rear-end/Java/14-AdvancedObjectOriented(Interface).html\",\"title\":\"😢 14.面向对象进阶(接口)\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"😢 14.面向对象进阶(接口)\",\"tag\":[\"Java\"],\"recommend\":15,\"description\":\"1. 抽象类 1.1 概述 1.1.1 抽象类引入 ​ 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://soft-vault.com/rear-end/Java/14-AdvancedObjectOriented(Interface).html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Night.Soul\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"😢 14.面向对象进阶(接口)\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"1. 抽象类 1.1 概述 1.1.1 抽象类引入 ​ 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:image\",\"content\":\"https://img.picgo.net/2023/11/06/image-2023110618125324669f1d5644e1d6d11.png\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"meta\",{\"name\":\"twitter:image:alt\",\"content\":\"😢 14.面向对象进阶(接口)\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Night.Soul\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"😢 14.面向对象进阶(接口)\\\",\\\"image\\\":[\\\"https://img.picgo.net/2023/11/06/image-2023110618125324669f1d5644e1d6d11.png\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Night.Soul\\\",\\\"url\\\":\\\"https://github.com/NightSquirrl\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1. 抽象类\",\"slug\":\"_1-抽象类\",\"link\":\"#_1-抽象类\",\"children\":[{\"level\":3,\"title\":\"1.1 概述\",\"slug\":\"_1-1-概述\",\"link\":\"#_1-1-概述\",\"children\":[]},{\"level\":3,\"title\":\"1.2 abstract使用格式\",\"slug\":\"_1-2-abstract使用格式\",\"link\":\"#_1-2-abstract使用格式\",\"children\":[]},{\"level\":3,\"title\":\"1.3 抽象类的特征\",\"slug\":\"_1-3-抽象类的特征\",\"link\":\"#_1-3-抽象类的特征\",\"children\":[]},{\"level\":3,\"title\":\"1.4 抽象类的细节\",\"slug\":\"_1-4-抽象类的细节\",\"link\":\"#_1-4-抽象类的细节\",\"children\":[]},{\"level\":3,\"title\":\"1.5 抽象类存在的意义\",\"slug\":\"_1-5-抽象类存在的意义\",\"link\":\"#_1-5-抽象类存在的意义\",\"children\":[]}]},{\"level\":2,\"title\":\"2. 接口\",\"slug\":\"_2-接口\",\"link\":\"#_2-接口\",\"children\":[{\"level\":3,\"title\":\"2.1 概述\",\"slug\":\"_2-1-概述\",\"link\":\"#_2-1-概述\",\"children\":[]},{\"level\":3,\"title\":\"2.2 定义格式\",\"slug\":\"_2-2-定义格式\",\"link\":\"#_2-2-定义格式\",\"children\":[]},{\"level\":3,\"title\":\"2.3 接口成分的特点\",\"slug\":\"_2-3-接口成分的特点\",\"link\":\"#_2-3-接口成分的特点\",\"children\":[]},{\"level\":3,\"title\":\"2.4 基本的实现\",\"slug\":\"_2-4-基本的实现\",\"link\":\"#_2-4-基本的实现\",\"children\":[]},{\"level\":3,\"title\":\"2.5 接口与接口的多继承\",\"slug\":\"_2-5-接口与接口的多继承\",\"link\":\"#_2-5-接口与接口的多继承\",\"children\":[]},{\"level\":3,\"title\":\"2.6扩展：接口的细节\",\"slug\":\"_2-6扩展-接口的细节\",\"link\":\"#_2-6扩展-接口的细节\",\"children\":[]}]},{\"level\":2,\"title\":\"3. 内部类\",\"slug\":\"_3-内部类\",\"link\":\"#_3-内部类\",\"children\":[{\"level\":3,\"title\":\"3.1 概述\",\"slug\":\"_3-1-概述\",\"link\":\"#_3-1-概述\",\"children\":[]},{\"level\":3,\"title\":\"3.2 内部类的分类\",\"slug\":\"_3-2-内部类的分类\",\"link\":\"#_3-2-内部类的分类\",\"children\":[]},{\"level\":3,\"title\":\"3.3 成员内部类\",\"slug\":\"_3-3-成员内部类\",\"link\":\"#_3-3-成员内部类\",\"children\":[]},{\"level\":3,\"title\":\"3.4 成员内部类的细节\",\"slug\":\"_3-4-成员内部类的细节\",\"link\":\"#_3-4-成员内部类的细节\",\"children\":[]},{\"level\":3,\"title\":\"3.5 成员内部类面试题\",\"slug\":\"_3-5-成员内部类面试题\",\"link\":\"#_3-5-成员内部类面试题\",\"children\":[]},{\"level\":3,\"title\":\"3.6 成员内部类内存图\",\"slug\":\"_3-6-成员内部类内存图\",\"link\":\"#_3-6-成员内部类内存图\",\"children\":[]}]},{\"level\":2,\"title\":\"3.7 静态内部类\",\"slug\":\"_3-7-静态内部类\",\"link\":\"#_3-7-静态内部类\",\"children\":[]},{\"level\":2,\"title\":\"3.8 局部内部类\",\"slug\":\"_3-8-局部内部类\",\"link\":\"#_3-8-局部内部类\",\"children\":[]},{\"level\":2,\"title\":\"3.9 匿名内部类【重点】\",\"slug\":\"_3-9-匿名内部类【重点】\",\"link\":\"#_3-9-匿名内部类【重点】\",\"children\":[{\"level\":3,\"title\":\"3.9.1 概述\",\"slug\":\"_3-9-1-概述\",\"link\":\"#_3-9-1-概述\",\"children\":[]},{\"level\":3,\"title\":\"3.9.2 格式\",\"slug\":\"_3-9-2-格式\",\"link\":\"#_3-9-2-格式\",\"children\":[]},{\"level\":3,\"title\":\"3.9.2 什么时候用到匿名内部类\",\"slug\":\"_3-9-2-什么时候用到匿名内部类\",\"link\":\"#_3-9-2-什么时候用到匿名内部类\",\"children\":[]},{\"level\":3,\"title\":\"3.9.3 匿名内部类前提和格式\",\"slug\":\"_3-9-3-匿名内部类前提和格式\",\"link\":\"#_3-9-3-匿名内部类前提和格式\",\"children\":[]},{\"level\":3,\"title\":\"3.9.4 使用方式\",\"slug\":\"_3-9-4-使用方式\",\"link\":\"#_3-9-4-使用方式\",\"children\":[]},{\"level\":3,\"title\":\"3.9.5 匿名内部类的特点\",\"slug\":\"_3-9-5-匿名内部类的特点\",\"link\":\"#_3-9-5-匿名内部类的特点\",\"children\":[]},{\"level\":3,\"title\":\"3.9.6 匿名内部类的使用场景\",\"slug\":\"_3-9-6-匿名内部类的使用场景\",\"link\":\"#_3-9-6-匿名内部类的使用场景\",\"children\":[]}]}],\"readingTime\":{\"minutes\":17.81,\"words\":5343},\"filePathRelative\":\"rear-end/Java/14-AdvancedObjectOriented(Interface).md\",\"excerpt\":\"<h2>1. 抽象类</h2>\\n<h3>1.1 概述</h3>\\n<h4>1.1.1 抽象类引入</h4>\\n<p>​\\t父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p>\\n<ul>\\n<li><strong>抽象方法</strong> ： 没有方法体的方法。</li>\\n<li><strong>抽象类</strong>：包含抽象方法的类。</li>\\n</ul>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
