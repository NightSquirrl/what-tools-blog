---
title: Vue 面试题
tag:
  - 面试
  - Vue
---

## 1. Vue.js 与其他前端框架（如React和Angular）相比有什么优势和区别？

<details>
  <summary>点击展开/折叠</summary>

1. 简单性和易用性：

Vue.js 是一款轻量级框架，容易学习和上手。它提供了直观的API和清晰的文档，使开发者可以迅速构建应用程序。
React 和 Angular 在某些方面更复杂，需要更多的学习成本。

2. 渐进式框架：

Vue.js 被称为渐进式框架，允许你逐步采用它的特性。这意味着你可以在现有项目中集成Vue.js，而不必一次性重写整个应用。
React 和 Angular 在集成到现有项目时可能需要更多的工作。

3. 双向数据绑定：

Vue.js 提供了直接的双向数据绑定，使数据在视图和模型之间保持同步。这使得开发人员更容易管理应用程序的状态。
React 和 Angular 也支持数据绑定，但它们的实现方式略有不同。

4. 组件化开发：

Vue.js、React 和 Angular 都鼓励组件化开发，但Vue.js在这方面表现出色。Vue组件的定义非常简单，易于复用和维护。
React 使用JSX来创建组件，Angular使用模板。这些框架的组件系统也很强大，但可能需要更多的配置。

5. 生态系统和社区：

React 和 Angular 有庞大的生态系统和活跃的社区支持，有丰富的第三方库和插件。
Vue.js 的生态系统也在不断壮大，虽然相对较小，但社区也非常积极。

6. 性能：

Vue.js 在性能方面表现良好，具有虚拟DOM机制，可以高效地更新视图。
React 也使用虚拟DOM，性能也很出色。Angular 在某些情况下可能需要更多的性能优化工作。

7. 工具和生态系统：

Vue.js 提供了一些强大的工具，如Vue CLI，用于快速搭建项目，并与Vue Router和Vuex等官方库集成。
React 和 Angular 也有类似的工具和库，但Vue的工具生态系统在某些方面更加直观和易用。

使用案例：

Vue.js 适用于中小型应用程序和单页面应用程序（SPA），以及需要快速原型开发的项目。
React 和 Angular 适用于各种规模的应用，包括大型企业级应用。总之，选择使用哪个前端框架取决于项目的需求和团队的偏好。Vue.js在简单性、易用性和渐进式开发方面具有优势，适合许多项目，但React和Angular在大型应用和企业级项目中也有其优势。
</details>

### Vue 优点

> 响应式编程

> 组件化开发

> 虚拟 DOM

## 2. Vue2 和 Vue3 的区别？

<details>
  <summary>显示详情</summary>

Vue.js 2 和 Vue.js 3 之间存在一些重要的区别和改进。以下是一些主要的区别和特点：
> 性能优化：

Vue 3 在底层进行了许多性能优化，包括虚拟 DOM 的升级，使其更快速和高效。
Vue 3 引入了懒加载（Lazy Loading）和静态提升（Static Hoisting）等优化策略，进一步提高了性能。

> Composition API：

Vue 3 引入了 Composition API，这是一个基于函数的 API，可以更灵活地组织和重用组件逻辑。
Composition API 允许开发者按功能划分代码，提高了代码的可读性和维护性。

> 更小的包体积：

Vue 3 的核心库体积更小，因此加载更快。
Vue 3 支持按需加载，使得只引入需要的功能，进一步减小包体积。

> Teleport：

Vue 3 引入了 Teleport，允许将组件的内容渲染到 DOM 中的任何位置，这在处理模态框、弹出菜单等场景中非常有用。

> Fragments：

Vue 3 支持 Fragments，允许组件返回多个根元素，而不需要额外的容器元素。

> 全局 API 的修改：

Vue 3 对全局 API 进行了一些修改，使其更符合现代 JavaScript 的标准。
例如，Vue.component 现在改为 app.component，Vue.directive 改为 app.directive，Vue.mixin 改为 app.mixin。

> 新的生命周期钩子：

Vue 3 引入了新的生命周期钩子，如 onBeforeMount 和 onBeforeUpdate，以提供更精确的控制和更好的性能优化机会。

> TypeScript 支持改进：

Vue 3 对 TypeScript 的支持更加完善，提供了更好的类型推断和类型检查。

> 响应式系统的改进：

Vue 3 对响应式系统进行了改进，提供了更好的 TypeScript 支持，并且更加高效。



总的来说，Vue.js 3 在性能、开发体验和可维护性等方面都有显著的改进。然而，Vue 2 仍然是一个稳定的版本，具有广泛的生态系统和支持，开发者可以根据项目需求来选择使用哪个版本。如果你正在开始一个新项目，Vue 3 可能是一个更好的选择，因为它具备了许多优势和改进。如果你正在维护一个 Vue 2 项目，也可以考虑逐渐迁移到 Vue 3，以获得性能和开发体验上的改进。
</details>





## 3. Vue实例与组件之间的区别是什么？ 它们如何进行通信？

<details>
<summary>点击展开/折叠</summary>

Vue.js 中的 Vue 实例（Vue Instance）和组件（Components）是两个不同的概念，它们之间有一些重要的区别，同时也有不同的方式来进行通信。

1. Vue 实例（Vue Instance）：

Vue 实例是 Vue.js 的核心概念之一。它是一个独立的 Vue 对象，用来管理应用的状态、行为和生命周期。
通常，一个 Vue 应用的根实例会被创建，它管理整个应用的数据和方法。你可以使用 new Vue() 来创建一个 Vue 实例。

2. 组件（Components）：

组件是 Vue.js 中的可复用的代码块，用于构建用户界面。每个组件都有自己的状态、行为和模板。
组件可以像标签一样在模板中使用，允许你构建复杂的用户界面，将界面分解成可维护的部分。
通过 Vue.component 或使用单文件组件 (.vue 文件) 的方式定义组件。

通信方式：
在 Vue.js 中，Vue 实例和组件之间可以通过以下方式进行通信：
1. Props（属性）：

父组件可以通过 props 向子组件传递数据。子组件通过 props 接收数据并在自己的模板中使用。
这是一种单向数据流的方式，父组件向子组件传递数据。

2. 自定义事件：

[详细的通信方式](/web/Vue/通信方式)

子组件可以通过触发自定义事件来向父组件通知事件发生。父组件可以监听这些事件并执行相应的操作。
这是一种从子组件到父组件的通信方式。

3. 状态管理（如Vuex）：

对于大型应用程序，可以使用状态管理库如 Vuex 来管理应用的状态。它提供了一个集中的状态存储，所有组件都可以访问和修改其中的数据。
这是一种跨组件通信的高级方式。

4. 依赖注入：

Vue.js 提供了依赖注入机制，允许你在祖先组件中注册一些数据，然后在后代组件中访问这些数据，而不需要通过 props 一层层传递。
依赖注入通常用于一些全局配置或主题样式的传递。

总结：
Vue 实例是整个应用的根对象，而组件是应用中的可复用模块。它们之间的通信主要通过 props 和自定义事件来实现，但对于更复杂的状态管理，可以使用 Vuex 或其他状态管理库。
</details>



## 4. Vue 实现双向绑定的原理

<details>
  <summary>显示详情</summary>
  Vue2.x 采用数据劫持结合发布订阅模式（PubSub 模式）的方式

通过 ==Object.defineProperty== 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，==Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。==用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

Vue 的数据双向绑定整合了 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化->视图更新，视图交互变化（例如 input 操作）->数据 model 变更的双向绑定效果。



Vue3.x 放弃了 Object.defineProperty ，使用 ES6 原生的 Proxy，来解决以前使用 Object.defineProperty 所存在的一些问题。
</details>

## 5. 说一下对 *Vue2.x* 响应式原理的理解

<details>
  <summary>显示详情</summary>
    Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。

</details>



## 6. Vue中的计算属性和观察者的作用是什么？它们有什么区别？

<details>
  <summary>显示详情</summary>

==计算属性(Computed Properties)==

计算属性是Vue.js中的一种属性类型，它的值是基于其他数据属性计算而来的，类似于一个函数。计算属性的主要作用是将计算逻辑封装起来，以便在模板中直接引用，而且它们具有缓存机制，只有在依赖的数据发生变化时才会重新计算。
主要特点和作用：

用于派生或计算基于现有数据属性的值。
具有缓存机制，只有在相关数据发生变化时才会重新计算，提高性能。
在模板中可以像普通属性一样直接引用。
计算属性一般用于简单的数据转换、筛选、格式化等操作。

==观察者(Watchers)==

观察者是Vue.js中的一种方式，用于在数据变化时执行自定义的异步或开销较大的操作。你可以监听一个或多个数据属性的变化，并在数据变化时执行特定的函数。

主要特点和作用：

- 用于在数据变化时执行自定义的操作，例如异步请求或复杂的数据处理。
- 不具有缓存机制，每次数据变化都会触发执行。
- 需要手动编写观察者函数来处理数据变化。
- 可以监听多个数据属性的变化。



**区别：**

1. **计算属性**主要用于对数据的转换和派生，具有缓存机制，只有在相关数据变化时才会重新计算，适合用于简单的数据处理。它们在模板中可以像普通属性一样直接引用。
2. **观察者**用于在数据变化时执行自定义的操作，没有缓存机制，每次数据变化都会触发执行。适合处理复杂的异步操作或需要监听多个数据变化的情况。


</details>



## 7. 请解释 Composition API 是什么以及它的优势是什么？

<details>
  <summary>显示详情</summary>

Composition API 是 Vue.js 3 中引入的一种新的组件组织方式，它允许你按功能划分和组织组件的代码逻辑。这是一种基于函数的 API 风格，与传统的 Options API 相对立，它的主要优势包括：


更灵活的代码组织： Composition API 允许你将一个组件的代码逻辑分成多个功能相关的部分，每个部分都是一个独立的函数。这使得代码更加清晰，易于维护和测试。你可以更容易地重用代码逻辑，将其应用于多个组件。


更好的类型推断： Composition API 配合 TypeScript 使用.
</details>



## 8. Vue3 中有那些性能优化措施

虚拟 DOM 重写

响应式系统的重写

树懒加载

静态树提升

Tree-shaking

Composition-API

更好的事件处理

Fragment 和 Teleport

Suspense

编译器优化



## 9. Vue 3 中对全局 API 进行了哪些修改？如何使用这些修改后的 API？

<details>
<summary>显示详情</summary>


1. 创建 Vue 实例

   1. **修改前（Vue 2）**：在 Vue 2 中，你可以使用 `new Vue()` 创建根 Vue 实例。

   2. **修改后（Vue 3）**：在 Vue 3 中，你可以使用 `createApp()` 来创建应用实例，例如

   3. ```js
      import { createApp } from 'vue';
      const app = createApp(App);
      app.mount('#app');
      ```

2. 全局组件注册

   1. **修改前（Vue 2）**：在 Vue 2 中，你可以使用 `Vue.component()` 全局注册组件。

   2. **修改后（Vue 3）**：在 Vue 3 中，你可以使用 `app.component()` 注册全局组件，例如：

   3. ```js
      app.component('my-component', MyComponent);
      ```

3. 过滤器

   1. **修改前（Vue 2）**：Vue 2 中支持过滤器，但在 Vue 3 中已经移除了过滤器的概念。你可以使用计算属性或方法来代替过滤器的功能。

4. 混入

   1. **修改前（Vue 2）**：在 Vue 2 中，你可以使用 `mixins` 选项来混入组件的选项。

   2. **修改后（Vue 3）**：在 Vue 3 中，你可以使用 `mix` 函数来实现类似的功能，例如：

   3. ```js
      import { defineComponent, ref, mix } from 'vue';
      
      const mixin = {
        data() {
          return {
            message: 'Hello from mixin'
          };
        }
      };
      
      const MyComponent = defineComponent({
        mixins: [mixin],
        setup() {
          const count = ref(0);
          return {
            count
          };
        },
        template: `
          <div>
            {{ message }}
            {{ count }}
          </div>
        `
      });
      ```

5. 自定义指令

   1. **修改前（Vue 2）**：在 Vue 2 中，你可以使用 `Vue.directive()` 注册全局自定义指令。

   2. **修改后（Vue 3）**：在 Vue 3 中，你可以使用 `app.directive()` 注册全局自定义指令，例如：

   3. ```js
      app.directive('my-directive', {
        // 自定义指令的定义
      });
      
      ```

</details>

## 10. 解释 Vue 3 中的响应式系统是如何工作的？

<details>
<summary>显示详情</summary>

1. **初始化**：
   - 当你创建一个Vue 3组件或应用程序时，Vue会初始化一个响应式系统的实例。
2. **数据定义**：
   - 你通过在组件的 `setup` 函数中创建响应式数据。这可以通过 `ref`、`reactive`、或 `computed` 来实现。
3. **数据依赖追踪**：
   - 当组件渲染时，Vue 会自动追踪数据属性的依赖关系。这意味着Vue知道哪些数据属性被用于渲染视图。
4. **响应式依赖收集**：
   - Vue 会在组件渲染期间收集数据属性的依赖，构建一个依赖关系图。
5. **数据变更时触发**：
   - 当响应式数据属性发生变化时，Vue 会通知依赖于该数据属性的视图更新。
6. **批量更新**：
   - Vue 3 会将多个数据变更的通知进行批处理，以最小化 DOM 更新操作，提高性能。
7. **异步更新队列**：
   - Vue 3 使用微任务队列（如 `Promise` 或 `nextTick`）来处理数据更新，确保在同一事件循环中的多次数据变更只触发一次视图更新。
8. **视图更新**：
   - 一旦数据变更通知到视图，Vue 3 会重新渲染相关的组件部分，使其与最新的数据保持同步。
9. **计算属性和侦听器**：
   - Vue 3 允许你使用计算属性（`computed`）和侦听器（`watch`）来处理数据的派生和监听变化，这些特性也依赖于响应式系统来工作。

总的来说，Vue 3的响应式系统通过数据依赖追踪和自动的视图更新机制，实现了数据与视图之间的自动同步。这使得开发者可以更专注于数据的处理，而不必手动操作DOM，提高了开发效率并改善了代码的可维护性。

</details>

##  11. Vue2 中是如何检测数组的变化

<details>
<summary>详细展开</summary>


将数组的常用方法进行了重写.

Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

流程:

1. 初始化传入 data 数据执行 initData [初始化]
2. 将数据进行观测 new Observer [Observer]
3. 将数组原型方法指向重写的原型 [重定向]
4. 深度观察数组中的引用类型[引用]

==有两种情况无法检测到数组的变化。==

1. 当利用索引直接设置一个数组项时，例如 vm.items[indexOfItem] = newValue
2. 当修改数组的长度时，例如 vm.items.length = newLength

替代方案:

```js

//使用该方法进行更新视图

// vm.$set，Vue.set的一个别名

vm.$set(vm.items, indexOfItem, newValue)


//使用该方法进行更新视图

// Array.prototype.splice

vm.items.splice(indexOfItem, 1, newValue)



```
</details>




## 12. *Vue3.x* 响应式数据

<details>
<summary>显示详情</summary>


- *Vue3.x* 响应式数据原理是什么？
- *Proxy* 只会代理对象的第一层，那么 *Vue3* 又是怎样处理这个问题的呢？
- 监测数组的时候可能触发多次 *get/set*，那么如何防止触发多次呢？



采用了 Proxy.

1. Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应

2. Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。

3. Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

4. Proxy 有多达 13 种拦截方法

5. Proxy作为新标准将受到浏览器厂商重点持续的性能优化

**Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？**

判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。

**监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？**

我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。


</details>



## 13. 🤬*vue2.x* 和 *vue3.x* 渲染器的 *diff* 算法分别说一下？

简单来说，diff 算法有以下过程

- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心 diff)
- 递归比较子节点

正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从O(n^3) -> O(n)，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。

**Vue2 的核心 Diff 算法采用了双端比较的算法**，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

**Vue3.x 借鉴了 ivi 算法和 inferno 算法**

在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。



## 14. *Vue* 的路由实现

- 解释 *hash* 模式和 *history* 模式的实现原理
- 说一下 router与route 的区别
- *vueRouter* 有哪几种导航守卫？
- 解释一下 *vueRouter* 的完整的导航解析流程是什么

==解释 *hash* 模式和 *history* 模式的实现原理==

Hash 模式最大的特点是 url 中有#

后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。

history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 URL，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作。

==两种模式的区别==

- 首先是在 URL 的展示上，hash 模式有“#”，history 模式没有
- 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由
- 在兼容性上，hash 可以支持低版本浏览器和 IE

==说一下 router与route 的区别==

$route 对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query 对象等。

==**vueRouter 有哪几种导航守卫？**==

- 全局前置/钩子：beforeEach、beforeR-esolve、afterEach
- 路由独享的守卫：beforeEnter
- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

==**解释一下 vueRouter 的完整的导航解析流程是什么**==

一次完整的导航解析流程如下：

- 1.导航被触发。
- 2.在失活的组件里调用离开守卫。
- 3.调用全局的 beforeEach 守卫。
- 4.在重用的组件里调用 beforeRouteUpdate 守卫（2.2+）。
- 5.在路由配置里调用 beforeEnter。
- 6.解析异步路由组件。
- 7.在被激活的组件里调用 beforeRouteEnter。
- 8.调用全局的 beforeResolve 守卫（2.5+）。
- 9.导航被确认。
- 10.调用全局的 afterEach 钩子。
- 11.触发 DOM 更新。
- 12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。



## 15. *Vue* 组件的 *data* 为什么必须是函数

> 在组件复用的时候 为每一个组件实例创建一份私有的数据空间!

组件中的 data 写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。



## 16. Vue 修饰符

分为三类

- 事件修饰符

- 按键修饰符

- 表单修饰符

**事件修饰符**

在事件处理程序中调用 *event.preventDefault* 或 *event.stopPropagation* 方法是非常常见的需求。尽管可以在 *methods* 中轻松实现这点，但更好的方式是：*methods* 只有纯粹的数据逻辑，而不是去处理 *DOM* 事件细节。

为了解决这个问题，*vue* 为 *v-on* 提供了事件修饰符。通过由点 *.* 表示的指令后缀来调用修饰符。

常见的事件修饰符如下：

- *.stop*：阻止冒泡。
- *.prevent*：阻止默认事件。
- *.capture*：使用事件捕获模式。
- *.self*：只在当前元素本身触发。
- *.once*：只触发一次。
- *.passive*：默认行为将会立即触发。

**按键修饰符**

除了事件修饰符以外，在 *vue* 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。

- .*left*：左键
- .*right*：右键
- .*middle*：滚轮
- .*enter*：回车
- .*tab*：制表键
- .*delete*：捕获 “删除” 和 “退格” 键
- .*esc*：返回
- .*space*：空格
- .*up*：上
- .*down*：下
- .*left*：左
- .*right*：右
- .*ctrl*：*ctrl* 键
- .*alt*：*alt* 键
- .*shift*：*shift* 键
- .*meta*：*meta* 键

**表单修饰符**

*vue* 同样也为表单控件也提供了修饰符，常见的有 *.lazy*、*.number* 和 *.trim*。

- .*lazy*：在文本框失去焦点时才会渲染
- .*number*：将文本框中所输入的内容转换为number类型
- .*trim*：可以自动过滤输入首尾的空格



## 17. **说一下 ref 的作用是什么？**

*ref* 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 *$refs* 对象上。其特点是：

- 如果在普通的 *DOM* 元素上使用，引用指向的就是 *DOM* 元素
- 如果用在子组件上，引用就指向组件实例

所以常见的使用场景有：

1. 基本用法，本页面获取 *DOM* 元素
2. 获取子组件中的 *data*
3. 调用子组件中的方法

## 18.  **如何实现vue 项目中的性能优化？**

**编码阶段**

- 尽量减少 *data* 中的数据，*data* 中的数据都会增加 *getter* 和 *setter*，会收集对应的 *watcher*
- *v-if* 和 *v-for* 不能连用
- 如果需要使用 *v-for* 给每项元素绑定事件时使用事件代理
- *SPA* 页面采用 *keep-alive* 缓存组件
- 在更多的情况下，使用 *v-if* 替代 *v-show*
- *key* 保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

**SEO 优化**

- 预渲染
- 服务端渲染 *SSR*

**打包优化**

- 压缩代码
- *Tree Shaking/Scope Hoisting*
- 使用 *cdn* 加载第三方模块
- 多线程打包 *happypack*
- *splitChunks* 抽离公共文件
- *sourceMap* 优化

**用户体验**

- 骨架屏
- *PWA*

还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 *gzip* 压缩等。



## 19. **vue 中的 spa 应用如何优化首屏加载速度?**

优化首屏加载可以从这几个方面开始：

- 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
- 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验
- gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。
- http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。
- 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
- 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
- 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
- 使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化
- 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程
- 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化
- 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
- 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求
- 压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图

## 20. **既然Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？**

现代前端框架有两种方式侦测变化，一种是 *pull*，一种是 *push*。

***pull***

其代表为 *React*，我们可以回忆一下 *React* 是如何侦测到变化的。

我们通常会用 *setState API* 显式更新,然后 *React* 会进行一层层的 *Virtual Dom Diff* 操作找出差异，然后 *Patch* 到 *DOM* 上，==*React* 从一开始就不知道到底是哪发生了变化,只是知道「有变化了」==,然后再进行比较暴力的 *Diff* 操作查找「哪发生变化了」，另外一个代表就是 *Angular* 的脏检查操作。

***push***

*Vue* 的响应式系统则是 *push* 的代表，当 *Vue* 程序初始化的时候就会对数据 *data* 进行依赖的收集，一但数据发生变化，==响应式系统就会立刻得知==，因此 *Vue* 是一开始就知道是「在哪发生变化了」

但是这又会产生一个问题，通常绑定一个数据就需要一个 *Watcher*，一但我们的绑定细粒度过高就会产生大量的 *Watcher*，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 *Vue* 的设计是选择中等细粒度的方案，在组件级别进行 *push* 侦测的方式，也就是那套响应式系统。

通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行 *Virtual Dom Diff* 获取更加具体的差异，而 *Virtual Dom Diff* 则是 *pull* 操作，*Vue* 是 *push + pull* 结合的方式进行变化侦测的。\



## 21. 🤬**Vue 中的 Key 的作用是什么？**

key 的作用主要是为了高效的更新虚拟 DOM。另外 *vue* 中在使用相同标签名元素的过渡切换时，也会使用到 *key* 属性，其目的也是为了让 *vue* 可以区分它们，否则 *vue* 只会替换其内部属性而不会触发过渡效果。

> 解析

其实不只是 *vue*，*react* 中在执行列表渲染时也会要求给每个组件添加上 *key* 这个属性。

要解释 *key* 的作用，不得不先介绍一下虚拟 *DOM* 的 *Diff* 算法了。

我们知道，*vue* 和 *react* 都实现了一套虚拟 *DOM*，使我们可以不直接操作 *DOM* 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 *Diff* 算法。

*vue* 和 *react* 的虚拟 *DOM* 的 *Diff* 算法大致相同，其核心有以下两点：

- 两个相同的组件产生类似的 *DOM* 结构，不同的组件产生不同的 *DOM* 结构。
- 同一层级的一组节点，他们可以通过唯一的 *id* 进行区分。

基于以上这两点，使得虚拟 *DOM* 的 *Diff* 算法的复杂度从 *O(n^3)* 降到了 *O(n)*。

![image-20240216012947257](https://img.picgo.net/2024/02/16/image-202402160129472579504e0a79cd57375.png)

当页面的数据发生变化时，*Diff* 算法只会比较同一层级的节点：

- 如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。
- 如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。

当某一层有很多相同的节点时，也就是列表节点时，*Diff* 算法的更新过程默认情况下也是遵循以上原则.

![image-20240216013839416](https://img.picgo.net/2024/02/16/image-20240216013839416d9a385fa0ed8aaa6.png)

我们希望可以在 *B* 和 *C* 之间加一个 *F*，*Diff* 算法默认执行起来是这样的：

![image-20240216013912674](https://img.picgo.net/2024/02/16/image-202402160139126746d49007d4a58c242.png)

即把 *C* 更新成 *F*，*D* 更新成 *C*，*E* 更新成 *D*，最后再插入 *E*

是不是很没有效率？

所以我们需要使用 *key* 来给每个节点做一个唯一标识，*Diff* 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。

![image-20240216013934932](/Users/zeroeldath/Library/Application Support/typora-user-images/image-20240216013934932.png)

## 22. **说一下你对 vue 事件绑定原理的理解？**

*vue* 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。

原生的事件绑定在普通元素上是通过 *@click* 进行绑定，在组件上是通过 *@click.native* 进行绑定，组件中的 *nativeOn* 是等价于 on 的。组件的事件绑定的 @click 是 vue 中自定义的on 方法来实现的,必须有 emit 才能够触发.

**原生事件绑定原理**

在 runtime下的patch.js中createPatchFunction执行了之后再赋值给patch。

createPatchFunction方法有两个参数，分别是nodeOps存放操作dom节点的方法和modules，modules是有两个数组拼接起来的，modules拼接完的数组中有一个元素就是events，事件添加就发生在这里。

events元素关联的就是events.js文件，在events中有一个updateDOMListeners方法，在events文件的结尾导出了一个对象，然后对象有一个属性叫做create，这个属性关联的就是updateDOMListeners方法。

在执行createPatchFunction方法时，就会将这两个参数传入，在createPatchFunction方法中接收了一个参数backend，在该方法中一开始进行backend的解构，就是上面的nodeOps和modules参数，解构完之后进入for循环。

在createPatchFunction开头定义了一个cbs对象。for循环遍历一个叫hooks的数组。hooks是文件一开头定义的一个数组，其中包括有create，for循环就是在cbs上定义一系列和hooks元素相同的属性，然后键值是一个数组，然后数组内容是modules里面的一些内容。这时就把events文件中导出来的create属性放在了cbs上。

当我们进入首次渲染的时候，会执行到patch函数里面的createElm方法，这个方法中就会调用invokeCreateHooks函数，用来处理事件系统，这里就是真正准备进行原生事件绑定的入口。invokeCreateHooks方法中，遍历了cbs.create数组里面的内容。然后把cbs.create里面的函数全部都执行一次，在cbs.create其中一个函数就是updateDOMListeners。

updateDOMListeners就是用来添加事件的方法，在这方法中会根据vnode判断是否有定义一个点击事件。如果没有点击事件就return。有的话就继续执行，给on进行赋值，然后进行一些赋值操作，将vnode.elm赋值给target，elm这个属性就是指向vnode所对应的真实dom节点，这里就是把我们要绑定事件的dom结点进行缓存，接下来执行updateListeners方法。在接下来执行updateListeners方法中调用了一个add的方法，然后在app方法中通过原生addEventListener把事件绑定到dom上。

**组件事件绑定原理**

在组件实例初始化会调用initMixin方法中的Vue.prototype._init，在init函数中，会通过initInternalComponent方法初始化组件信息，将自定义的组件事件放到_parentListeners上，下来就会调用initEvents来初始化组件事件，在initEvents中会实例上添加一个 _event对象，用于保存自定义事件，然后获取到 父组件给 子组件绑定的自定义事件，也就是刚才在初始化组件信息的时候将自定义的组件事件放在了_parentListeners上，这时候vm.$options._parentListeners就是自定义的事件。

最后进行判断，如果有自定义的组件事件就执行updateComponentListeners方法进行事件绑定，在updateComponentListeners方法中会调用updateListeners方法，并传传一个add方法进行执行，这个add方法里就是$on方法。



## 23. 🤬**说一下 vue 模版编译的原理是什么**

简单说，*Vue* 的编译过程就是将 *template* 转化为 *render* 函数的过程。会经历以下阶段：

- 生成 *AST* 树
- 优化
- *codegen*

首先解析模版，生成 *AST* 语法树(一种用 *JavaScript* 对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

*Vue* 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 *DOM* 也不会变化。那么优化过程就是深度遍历 *AST* 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。

编译的最后一步是将优化后的 *AST* 树转换为可执行的代码。

## 24. **v-on 可以实现监听多个方法么？**

可以监听多个方法。关于监听多个方法提供了几种不同的写法：

```js
写法一：<div v-on="{ 事件类型: 事件处理函数, 事件类型: 事件处理函数 }"></div>
写法二：<div @事件类型=“事件处理函数” @事件类型=“事件处理函数”></div>
写法三：在一个事件里面书写多个事件处理函数
<div @事件类型=“事件处理函数1，事件处理函数2”></div>
写法四：在事件处理函数内部调用其他的函数

```

> 示例代码如下:

```js
<template>
  <div>
    <!-- v-on在vue2.x中测试,以下两种均可-->
    <button v-on="{ mouseenter: onEnter, mouseleave: onLeave }">
      鼠标进来1
    </button>
    <button @mouseenter="onEnter" @mouseleave="onLeave">鼠标进来2</button>

    <!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号-->
    <button @click="a(), b()">点我ab</button>
    <button @click="one()">点我onetwothree</button>
  </div>
</template>
<script>
export default {
  methods: {
    //这里是es6对象里函数写法
    a() {
      console.log("a");
    },
    b() {
      console.log("b");
    },
    one() {
      console.log("one");
      this.two();
      this.three();
    },
    two() {
      console.log("two");
    },
    three() {
      console.log("three");
    },
    onEnter() {
      console.log("mouse enter");
    },
    onLeave() {
      console.log("mouse leave");
    },
  },
};
</script>

```

## 25. 说一下 vue 中 computed 和 methods 的区别是什么？

首先从表现形式上面来看， *computed* 和 *methods* 的区别大致有下面 *4* 点：

1. 在使用时，*computed* 当做属性使用，而 *methods* 则当做方法调用
2. *computed* 可以具有 *getter* 和 *setter*，因此可以赋值，而 *methods* 不行
3. *computed* 无法接收多个参数，而 *methods* 可以
4. *computed* 具有缓存，而 *methods* 没有

而如果从底层来看的话， *computed* 和 *methods* 在底层实现上面还有很大的区别。

*vue* 对 *methods* 的处理比较简单，只需要遍历 *methods* 配置中的每个属性，将其对应的函数使用 *bind* 绑定当前组件实例后复制其引用到组件实例中即可

而 *vue* 对 *computed* 的处理会稍微复杂一些。

## 26. **插槽与作用域插槽的区别是什么？**

插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。

作用域插槽给了子组件将数据返给父组件的能力，子组件一样可以复用，同时父组件也可以重新组织内容和样式。

## 27. vue 中相同逻辑如何进行抽离？

可以使用 *vue* 里面的混入（*mixin*）技术。混入（*mixin*）提供了一种非常灵活的方式，来将 *vue* 中相同的业务逻辑进行抽离。

例如：

- 在 *data* 中有很多是公用数据
- 引用封装好的组件也都是一样的
- *methods、watch、computed* 中也都有大量的重复代码

当然这个时候可以将所有的代码重复去写来实现功能，但是我们并不不推荐使用这种方式，无论是工作量、工作效率和后期维护来说都是不建议的，这个时候 *mixin* 就可以大展身手了。

一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。

**混入技术特点**

- 当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。
- 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
- 值为对象的选项，例如 *methods、components* 和 *directives*，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

## 28. 说一下 vue3.0 是如何变得更快的？

**优化 Diff 算法**

相比 *Vue 2*，*Vue 3* 采用了更加优化的渲染策略。去掉不必要的虚拟 *DOM* 树遍历和属性比较，因为这在更新期间往往会产生最大的性能开销。

这里有三个主要的优化：

- 首先，在 *DOM* 树级别。

在没有动态改变节点结构的模板指令（例如 *v-if* 和 *v-for*）的情况下，节点结构保持完全静态。

当更新节点时，不再需要递归遍历 *DOM* 树。所有的动态绑定部分将在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟 *DOM* 的大部分开销。

- 其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。
- 第三，在元素级别。

编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。

例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。

综合起来，这些技术大大改进了渲染更新基准，*Vue 3.0* 有时占用的 *CPU* 时间不到 *Vue 2* 的十分之一。

**体积变小**

重写后的 *Vue* 支持了 *tree-shaking*，像修剪树叶一样把不需要的东西给修剪掉，使 *Vue 3.0* 的体积更小。

需要的模块才会打入到包里，优化后的 *Vue 3.0* 的打包体积只有原来的一半（*13kb*）。哪怕把所有的功能都引入进来也只有 *23kb*，依然比 *Vue 2.x* 更小。像 *keep-alive、transition* 甚至 *v-for* 等功能都可以按需引入。

并且 *Vue 3.0* 优化了打包方法，使得打包后的 *bundle* 的体积也更小。

官方所给出的一份惊艳的数据：打包大小减少 *41%*，初次渲染快 *55%*，更新快 *133%*，内存使用减少 *54%*。

## 29. *vue* 为什么采用异步渲染

因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染；所以为了性能考虑，*Vue* 会在本轮数据更新后，再去异步更新视图。

异步渲染的原理：

1. 调用 *notify( )* 方法，通知 *watcher* 进行更新操作
2. 依次调用 watcher 的 update 方法
3. 对 watcher 进行去重操作（通过id）放到队列里
4. 执行完后异步清空这个队列，nextTick（flushSchedulerQueue）进行批量更新操作

## 30 .说一说相比 *vue3.x* 对比 *vue2.x* 变化

源码组织方式变化：使用 TS 重写

支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）

响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化

编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容

打包体积优化：移除了一些不常用的api（inline-template、filter）

生命周期的变化：使用setup代替了之前的beforeCreate和created

Vue3 的 template 模板支持多个根标签

Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore

Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例

Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props

父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下.

