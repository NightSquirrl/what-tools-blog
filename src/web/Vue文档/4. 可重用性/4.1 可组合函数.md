# 4.1 可组合函数

## 什么是“可组合函数”

### 在 Vue 应用的概念中，“可组合函数”是一个利用 Vue 组合式 API 来封装和复用有状态逻辑的函数

### 当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间而抽取一个可复用的函数。这个格式化函数封装了无状态的逻辑：它在接收一些输入后立刻返回所期望的输出

### 相比之下，有状态逻辑负责管理会随时变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在真实应用中，它也可以是像触摸手势或与数据库的连接状态这样的更复杂的逻辑

## 约定和最佳实践

### 命名

- 可组合函数约定用驼峰命名法命名，并以“use”作为开头

### 输入参数

- 尽管其响应性不依赖 ref，可组合函数仍可接收 ref 参数。如果编写的可组合函数会被其他开发者使用，你最好在处理输入参数时兼容 ref 而不只是原始的值。`unref() `工具函数会对此非常有帮助

- 如果你的可组合函数在接收 ref 为参数时会产生响应式 effect，请确保使用 `watch()` 显式地监听此 ref，或者在 `watchEffect() `中调用 `unref()` 来进行正确的追踪

### 返回值

- 你可能已经注意到了，我们一直在可组合函数中使用 `ref()` 而不是 `reactive()`。我们推荐的约定是可组合函数始终返回一个 ref 对象，这样该函数在组件中解构之后仍可以保持响应性

- 从可组合函数返回一个响应式对象会导致在对象解构过程中丢失与可组合函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接

- 如果你更希望以对象 property 的形式从可组合函数中返回状态，你可以将要返回的对象用 `reactive()` 包装，这样其中的 ref 会被自动解包

### 副作用

- 在可组合函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：

- 如果你在一个应用中使用了服务器端渲染 (SSR)，请确保在后置加载的声明钩子上执行 DOM 相关的副作用

- 确保在` onUnmounted()` 时清理副作用

### 使用限制

- 可组合函数在  或 `setup()` 钩子中，应始终被同步地调用。在某些场景下，你也可以在像 `onMounted()` 这样的生命周期钩子中使用他们

- 这些是 Vue 得以确定当前活跃的组件实例的条件。有能力对活跃的组件实例进行访问是必要的，以便：

	- 可以在可组合函数中注册生命周期钩子

	- 计算属性和监听器可以连接到当前组件实例，以便在组件卸载时处理掉

## 为更好的代码组织抽取可组合函数

### 抽取可组合函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数

## 在选项式 API 中使用可组合函数

### 如果你正在使用选项式 API，可组合函数必须在 `setup()` 中调用。且其返回的绑定必须在 `setup()` 中返回，以便暴露给 this 及其模板

## 与其他技巧的比较

### 相比于 `Mixin，mixins` 有三个主要的短板

- 不清晰的 property 来源

- 命名空间冲突

- 隐式的跨 mixin 交流

### 相比于无渲染组件

- 可组合函数相对于无渲染组件的主要优势是：可组合函数不会产生额外的组件实例开销。当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销


![4.13121b40e81102845.png](https://img.picgo.net/2024/02/10/4.13121b40e81102845.png)