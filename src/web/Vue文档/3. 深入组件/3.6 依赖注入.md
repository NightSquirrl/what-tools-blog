# 3.6 依赖注入

## Provide (供给)

### 要为组件后代供给数据，需要使用到 provide() 函数

### 如果不使用 ，请确保 provide() 是在 setup() 同步调用的

### provide() 函数接收两个参数

- 第一个参数被称为注入名，可以是一个字符串或是一个 Symbol

- 第二个参数是供给的值，值可以是任意类型，包括响应式的状态

### 供给的响应式状态使后代组件可以由此和供给者建立响应式的联系

## 应用层 Provide

### 除了供给一个组件的数据，我们还可以在整个应用层面做供给：

- app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')

### 应用级的供给在应用的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来供给值

## Inject (注入)

### 要注入祖先组件供给的数据，需使用 inject() 函数

- const message = inject('message')

### 如果供给的值是一个 ref，注入进来的就是它本身，而不会自动解包

export default {
  emits: [&#39;inFocus&#39;, &#39;submit&#39;],
  setup(props, ctx) {
    ctx.emit(&#39;submit&#39;)
  }
}
### 同样的，如果没有使用 ，inject() 需要在 setup() 同步调用

### 注入的默认值

- 默认情况下，inject 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告

- 如果在供给的一侧看来属性是可选提供的，那么注入时我们应该声明一个默认值，和 props 类似

## 配合响应性

### 当使用响应式 provide/inject 值时，建议尽可能将任何对反应式状态的变更都保持在 provider 内部。 这样可以确保 provide 的状态和变更操作都在同一个组件内，使其更容易维护

### 有的时候，我们可能需要在 injector 组件中更改数据。在这种情况下，我们推荐在 provider 组件内提供一个更改数据方法

### 如果你想确保从 provide 传过来的数据不能被 injector 的组件更改，你可以使用readonly() 来包装提供的值

## 使用 Symbol 作注入名

### 如果你正在构建大型的应用程序，包含非常多的依赖供给，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突


![3.64476f7c55458d470.png](https://img.picgo.net/2024/02/10/3.64476f7c55458d470.png)