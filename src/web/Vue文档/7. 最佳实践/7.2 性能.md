# 性能

## 概述

### Vue 的设计对于大多数常见的使用情况来说都是性能优秀的，不需要太多的手动优化。然而，总有一些具有挑战性的场景需要进行额外的细微调整

### 首先，让我们讨论一下网络性能的两个主要方面：

- 页面加载性能：应用展示出内容与首次访问时变为可交互的速度

- 更新性能：应用响应用户输入更新的速度

### 虽然最理想的情况是将两者都最大化，但是不同的前端架构往往会影响到在这些方面是否能达到更理想的性能

## 分析选项

### 为了提高性能，我们首先需要知道如何衡量它。在这方面，有一些很棒的工具可以提供帮助：

### 用于生产部署的负载性能分析：

- PageSpeed Insights

	- https://pagespeed.web.dev/

- WebPageTest

	- https://www.webpagetest.org/

### 用于本地开发期间的性能分析：

- Chrome 开发者工具“性能”面板

	- app.config.performance 将会开启 Vue 特有的性能标记，标记在 Chrome 开发者工具的性能时间线上

- Vue 开发者扩展 也提供了性能分析的功能

	- https://staging-cn.vuejs.org/guide/scaling-up/tooling.html#browser-devtools

## 页面加载优化

### 页面加载优化有许多跟框架无关的方面 - 这份 web.dev 指南 提供了一个全面的总结。这里，我们将主要关注和 Vue 相关的技巧

### 包体积与 Tree-shaking 优化

- 一个最有效的提升页面加载速度的方法就是压缩 JavaScript 打包产物的体积。当使用 Vue 时有下面一些办法来减小打包产物体积：

- 尽可能地采用构建步骤

- 在引入新的依赖项时要小心包体积膨胀！在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的

- 如果你基本上是以渐进式集成的模式使用 Vue，并选择避免使用构建步骤，请考虑使用 petite-vue (只有 6kb) 来代替

### 代码拆分

- 代码拆分是指构建工具将应用程序包拆分为多个较小的块，然后可以按需或并行加载

- 懒加载对于页面初次加载时的优化帮助极大，它帮助应用暂时略过了那些不是立即需要的功能。在 Vue 应用中，这常常与 Vue 的 异步组件 搭配使用，为组件树创建分离的代码块

- 如果在客户端侧通过 Vue Router 构建了路由，那么强烈建议使用异步组件作为路由组件

### SSR / SSG

- 纯粹的客户端渲染存在内容到达时间缓慢的问题。这可以通过采用服务端渲染 (SSR) 或者静态站点生成 (SSG) 来进行优化

## 更新优化

### props 稳定性

### v-once

- v-once 是一个内置的指令，可以用来渲染依赖运行时数据但无需再更新的内容。它的整个子树都会在未来的更新中被跳过

### v-memo

- v-memo 可以用来有条件地跳过某些大型子树或者 v-for 列表的更新

## 总体优化

### 大型虚拟列表

- 所有的前端应用中最常见的性能问题就是渲染大型列表。无论一个框架性能有多好，渲染成千上万个列表项都会变得很慢，因为浏览器需要处理大量的 DOM 节点

- 但是，我们并不需要立刻渲染出全部的列表。在大多数场景中，用户的屏幕尺寸只会展示这个巨大列表中的一小部分。我们可以通过列表虚拟化来提升性能，这项技术使我们只需要渲染用户视口中能看到的部分

- 要实现列表虚拟化并不简单，幸运的是，你可以直接使用现有的社区库：

	- vue-virtual-scroller

		- https://github.com/Akryum/vue-virtual-scroller

	- vue-virtual-scroll-grid

		- https://github.com/rocwang/vue-virtual-scroll-grid

### 减少大型不可变结构的响应性开销

- Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据变大时它也的确创造了不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。试想一下当一次渲染需要访问 100,000+ 属性的时候，这个开销在处理大型数组或层级很深的对象时变得无法忽略，因此，我们应该控制它只影响非常具体的使用情况

- Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来选择退出深度响应。浅层式 API 创建的状态只在其顶层是响应式的，并原封不动地显示所有下面层级的对象。这使得对深层级属性的访问变得更快，但代价是，我们现在必须将所有深层级对象视为不可变的，并且只能通过替换整个根状态来触发更新

### 避免不必要的组件抽象

- 有些时候我们会去创建 无渲染组件 或高阶组件 (用来渲染具有额外 props 的其他组件) 来实现更好的抽象或代码组织。虽然这并没有什么问题，但请记住，组件实例比普通 DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失

- 请注意，只减少几个实例不会有明显的效果，所以如果该组件在应用程序中只渲染了几次，就不用担心了。考虑这种优化的最佳场景还是在大型列表中。想象一下一个有 100 项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗



![7.2849806c88c8b219d.png](https://img.picgo.net/2024/02/10/7.2849806c88c8b219d.png)