# 测试

## 为什么需要测试

### 自动化测试通过预防回归，并鼓励将应用分解为可测试的函数、模块、类和组件，从而帮助你和你的团队快速、自信地构建复杂的 Vue 应用。与任何应用一样，新的 Vue 应用可能会以多种方式崩溃，因此，在发布前捕获并解决这些问题就变得十分重要

## 何时测试

### 尽早开始测试

## 测试的类型

### 单元测试：检查给定函数、类或可组合函数的输入是否产生预期的输出或副作用

### 组件测试：检查你的组件是否正常挂载和渲染、是否可以与之互动，以及表现是否符合预期。这些测试比单元测试导入了更多的代码，更复杂，需要更多时间来执行

### 端到端测试：检查跨越多个页面的功能，并对生产构建的 Vue 应用进行实际的网络请求。这些测试通常涉及到建立一个数据库或其他后端

## 单元测试

### 编写单元测试是为了验证小的、独立的代码单元是否按预期工作。一个单元测试通常覆盖单个函数、类、可组合函数或模块。单元测试侧重于逻辑的正确性，只关注应用整体功能的一小部分

### 一般来说，单元测试将捕获函数的业务逻辑和逻辑正确性的问题

### 在 Vue 应用中为业务逻辑编写单元测试与使用其他框架的应用没有明显区别，但有两种情况，你必须对 Vue 的特定功能进行单元测试：

- 可组合函数

- 组件

### 可组合函数

- 有一类 Vue 应用中特有的函数被称为 可组合函数，在测试过程中可能需要特殊处理

- 可在这里了解更多：https://staging-cn.vuejs.org/guide/scaling-up/testing.html#testing-composables

### 组件的单元测试

- 一个组件可以通过两种方式测试：

	- 白盒：单元测试

	- 黑盒：组件测试

### 推荐

- Vitest

### 其他选择

- Peeky

- Jest

## 组件测试

### 在 Vue 应用中，主要用组件来构建用户界面。因此，当验证应用的行为时，组件是一个很自然的独立单元。从粒度的角度来看，组件测试位于单元测试之上，可以被认为是集成测试的一种形式。你的 Vue 应用中大部分内容都应该由组件测试来覆盖，我们建议每个 Vue 组件都应有自己的组件测试文件

### 组件测试应该捕捉组件中的 prop、事件、提供的插槽、样式、CSS 类名、生命周期钩子，和其他相关的问题

### 组件测试不应该模拟子组件，而应该像用户一样，通过与组件互动来测试组件和其子组件之间的交互。例如，组件测试应该像用户那样点击一个元素，而不是编程式地与组件进行交互

### 组件测试主要需要关心组件的公开接口而不是内部实现细节。对于大部分的组件来说，公开接口包括触发的事件、prop 和插槽。当进行测试时，请记住，测试这个组件做了什么，而不是测试它是怎么做到的

### 推荐

- 对于 视图 的测试：根据输入 prop 和插槽断言渲染输出是否正确

- 对于 交互 的测试：断言渲染的更新是否正确或触发的事件是否正确地响应了用户输入事件

### 工具

- Vitest 对于组件和可组合函数都采用无头渲染的方式（例如 VueUse 中的 useFavicon 函数。组件和 DOM 都可以通过 @testing-library/vue 来测试

- Cypress 组件测试 会预期其准确地渲染样式或者触发原生 DOM 事件。可以搭配 @testing-library/cypress 这个库一同进行测试

### 挂载库

- 组件测试通常涉及到单独挂载被测试的组件，触发模拟的用户输入事件，并对渲染的 DOM 输出进行断言。有一些专门的工具库可以使这些任务变得更简单

- @testing-library/vue 是一个 Vue 的测试库，专注于测试组件而不依赖其他实现细节

- @vue/test-utils 是官方的底层组件测试库，用来提供给用户访问 Vue 特有的 API。@testing-library/vue 也是基于此库构建的。

- 建议：我们推荐使用 @testing-library/vue 测试应用中的组件, 因为它更匹配整个应用的测试优先级。只有在你构建高级组件、并需要测试内部的 Vue 特有 API 时再使用 @vue/test-utils

### 其他选择

- Nightwatch 是一个端到端测试运行器，支持 Vue 的组件测试

## 端到端（E2E）测试

### 推荐：Cypress

### 其他选项

- Playwright 也是一个非常好的端到端测试解决方案，支持测试范围更广的浏览器品类

- Nightwatch v2 是一个基于 Selenium WebDriver 的端到端测试解决方案。它的浏览器品类支持范围是最广的

## Vitest使用指南

### 添加 Vitest 到项目中

- > npm install -D vitest happy-dom @testing-library/vue@next

### 接着，更新你的 Vite 配置，添加上 test 选项块： CLI 的用户可能习惯于通过 webpack loader 来配置规范检查器
```js
// vite.config.js
import { defineConfig } from &#39;vite&#39;

export default defineConfig({
  // ...
  test: {
    // 启用类似 jest 的全局测试 API
    global: true,
    // 使用 happy-dom 模拟 DOM
    // 这需要你安装 happy-dom 作为对等依赖（peer dependency）
    environment: &#39;happy-dom&#39;
  }
})

```
### 接着在你的项目中创建名字以 `*.test.js` 结尾的文件。你可以把所有的测试文件放在项目根目录下的 test 目录中，或者放在源文件旁边的 test 目录中。Vitest 会使用命名规则自动搜索它们
```js
// MyComponent.test.js
import { render } from &#39;@testing-library/vue&#39;
import MyComponent from &#39;./MyComponent.vue&#39;

test(&#39;it should work&#39;, () => {
  const { getByText } = render(MyComponent, {
    props: {
      /* ... */
    }
  })

  // 断言输出
  getByText(&#39;...&#39;)
})
```
### 最后，在 package.json 之中添加测试命令，然后运行它
```json
{
  // ...
  'scripts': {
    'test': 'vitest'
  }
}
```
-------------
> npm test

![6.50e853bb301f71288.png](https://img.picgo.net/2024/02/10/6.50e853bb301f71288.png)


