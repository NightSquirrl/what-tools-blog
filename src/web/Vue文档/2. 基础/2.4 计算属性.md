# 2.4 计算属性

## 简介

### 模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让使其变得臃肿，难以维护

### 所以，推荐使用计算属性来描述依赖响应式状态的复杂逻辑

### `computed()` 方法期望接收一个 getter 函数，返回值为一个计算属性 ref

### Vue 的计算属性会自动追踪响应式依赖

## 计算属性缓存 vs 方法

### 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的

### 不同之处在于计算属性值会基于其响应式依赖被缓存

## 可写计算属性

### 计算属性默认仅能通过计算函数得出结果。当你尝试修改一个计算属性时，你会收到一个运行时警告

### 只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建

```vue
<script setup>
import { ref, computed } from &#39;vue&#39;

const firstName = ref(&#39;John&#39;)
const lastName = ref(&#39;Doe&#39;)

const fullName = computed({
  // getter
  get() {
    return firstName.value + &#39; &#39; + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(&#39; &#39;)
  }
})
</script>
```
## 最佳实践

### 计算函数不应有副作用

- 计算属性的计算函数应只做计算而没有任何其他的副作用

### 避免直接修改计算属性值

- 从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照

- 因此更改快照是没有意义的，应该更新它所依赖的源状态，以触发新一次计算


![2.4889717de6fcbf946.png](https://img.picgo.net/2024/02/10/2.4889717de6fcbf946.png)