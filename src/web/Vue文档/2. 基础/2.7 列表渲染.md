# 2.7 列表渲染

## v-for

### 可以使用 v-for 指令基于一个数组来渲染一个列表

```html
<li v-for='item in items'>
  {{ item.message }}
</li>
```
### 在 v-for 块中可以完整地访问父作用域内的 property

### 也支持使用可选的第二个参数表示当前项的位置索引

### 对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域

### 也可以使用 of 作为分隔符来替代 in，这也和 JavaScript 的迭代器语法非常相似

## v-for与对象

### 可以使用 v-for 来遍历一个对象的所有属性

### 也可以提供第二个参数表示属性名

### 第三个参数表示位置索引

## v-for和范围值

### 可以直接传给 v-for 一个整数值

- `{{ n }}`

### 在这种用例中，会将该模板基于 1...n 的取值范围重复多次

##  上的 v-for

### 与模板上的 v-if 类似，你也可以在  标签上使用 v-for 来渲染一个包含多个元素的块

```vue
<ul>
  <template v-for='item in items'>
    <li>{{ item.msg }}</li>
    <li class='divider' role='presentation'></li>
  </template>
</ul>
```
## v-for 与 v-if

### 同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显

### 当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名

<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
```vue
<li v-for='todo in todos' v-if='!todo.isComplete'>
  {{ todo.name }}
</li>
```
### 在外新包装一层  再在其上使用 v-for 可以解决这个问题

## 通过 key 管理状态

### Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染

### 默认模式是高效的，但只适用于列表渲染输出不依赖子组件状态或者临时 DOM 状态 (例如表单输入值)

### 为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个项目提供一个唯一的 key attribute

### 当你使用  时，也key 应该被放置在这个  容器上

```vue
<template v-for='todo in todos' :key='todo.name'>
  <li>{{ todo.name }}</li>
</template>
```
### 推荐在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 ，或者有意依赖默认行为来获得性能增益

### key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key

## 组件上使用 v-for

### 可以直接在组件上使用 v-for，和其他任何一般的元素没有区别

### 但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域

## 数组变化侦测

### 变更方法

- Vue 包装了一批侦听数组的变更方法，以至于这些方法可以触发视图更新。被包装的变更方法如下

- `push()、pop()、shift()、unshift()、splice()、sort()、reverse()`

### 非变更方法

- 指的是不会更改原数组的方法，比如`filter()，concat() 和 slice()`

- 当遇到的是非变更方法时，我们需要将旧的数组替换为新的

  // `item` 是一个数组的 ref
 ` items.value = item.values.filter((item) => item.message.match(/Foo/))`
- 你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用

## 展示过滤或排序后的结果

### 有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性

### 在计算属性中使用 `reverse() `和 `sort()` 请保持谨慎！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本

- `return numbers.reverse()`
+ `return [...numbers].reverse()`

![2.74ed4aff1d75e16bd.png](https://img.picgo.net/2024/02/10/2.74ed4aff1d75e16bd.png)