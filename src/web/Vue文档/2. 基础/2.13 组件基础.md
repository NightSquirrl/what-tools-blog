# 2.13 组件基础

## 定义一个组件

### 当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC)

```vue
<script setup>
import { ref } from &#39;vue&#39;

const count = ref(0)
</script>

<template>
  <button @click='count++'>You clicked me {{ count }} times.</button>
</template>
```
### 当不使用构建步骤时，一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义

```js
import { ref } from &#39;vue&#39;

export default {
  setup() {
    const count = ref(0)
    return { count }
  },
  template: `
    <button @click='count++'>
      You clicked me {{ count }} times.
    </button>`
  // 或者 `template: &#39;#my-template-element&#39;`
}
```
## 使用组件

### 要使用一个子组件，我们需要在父组件中导入它

### 通过 ，导入的组件都在模板中直接可用

```vue

<script setup>
import ButtonCounter from &#39;./ButtonCounter.vue&#39;
</script>

<template>
  <h1>Here is a child component!</h1>
  <ButtonCounter />
</template>
```
### 每当使用一个组件，就创建了一个新的实例，每一个组件都维护着自己的状态

### 在单文件组件中，推荐为子组件使用 PascalCase 的标签名，以此来和原生的 HTML 元素作区分。虽然原生 HTML 标签名是不区分大小写的，但 Vue 单文件组件是可以在编译中区分大小写的。我们也可以使用 /> 来关闭一个标签

### 如果你是直接在 DOM 中书写模板 (例如原生  元素的内容)，模板的编译将服从于原生 HTML 的解析行为。在这种情况下，你应该需要使用 kebab-case 形式并显式地关闭这些组件的标签

<!-- 如果模板时写在 DOM 中 -->
`<button-counter></button-counter>`
`<button-counter></button-counter>`
`<button-counter></button-counter>`
## 传递 props

### Props 是一种特别的 attributes，你可以在组件上声明注册

- `defineProps(['title'])`

### defineProps 是一个仅  中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板

### defineProps 会返回一个对象，其中包含了可以传递给组件的所有 props

### 如果你没有使用 ，props 必须以 props 选项的方式声明，props 对象会作为 setup() 函数的第一个参数

```js
export default {
  props: [&#39;title&#39;],
  setup(props) {
    console.log(props.title)
  }
}
```
### 一个组件可以有任意多的 props，默认情况下，任何值都可以传递给任何 prop

### 当一个 prop 被注册后，可以以自定义 attribute 的形式传递数据给它

`<BlogPost title='My journey with Vue' />`
`<BlogPost title='Blogging with Vue' />`
`<BlogPost title='Why Vue is so fun' />`
## 监听事件

### 组件实例提供了一个自定义事件系统。父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样

### 子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件

### 我们可以通过 defineEmits 宏来选择性地声明需要抛出的事件

<!-- BlogPost.vue -->
```vue
<script setup>
defineProps([&#39;title&#39;])
defineEmits([&#39;enlarge-text&#39;])
</script>
```
### 和 defineProps 类似，defineEmits 仅可用于  之中，并且不需要导入，返回的 emit 函数可以被用于在 JavaScript 代码中抛出事件

### 如果你没有在使用 ，你可以通过 emits 选项定义组件会抛出的事件。你可以从 setup() 函数的第二个参数，即 setup 上下文对象上访问到 emit 函数

```js
export default {
  emits: [&#39;enlarge-text&#39;],
  setup(props, ctx) {
    ctx.emit(&#39;enlarge-text&#39;)
  }
}
```
## 通过插槽来分配内容

### 在模板中，可以使用 作为一个占位符，之后的内容就会分配在这里

## 动态组件

### 通过 Vue 的  元素和特殊的 is attribute 实现动态组件

### 被传给 :is 的值可以是以下几种

- 被注册的组件名

- 导入的组件对象

### 当然你也可以使用 is attribute 来创建一般的 HTML 元素

### 当使用  来在多个组件间作切换时，组件会在被切换掉后卸载

### 我们可以通过  组件强制不活跃的组件仍然保持“存活”的状态

## DOM 模板解析注意事项

### 如果你想在 DOM 中直接书写 Vue 模板，Vue 则必须从 DOM 中获取模板字符串。因为浏览器的原生 HTML 解析行为，因此有一些需要注意的事项

### 注意事项

- 大小写区分

	- 使用kebab-case (短横线连字符) 形式

- 闭合标签

	- 在 DOM 模板中，我们必须显式地写出关闭标签

- 元素位置有限制


![2.137aa0e064e3b1b4b6.png](https://img.picgo.net/2024/02/10/2.137aa0e064e3b1b4b6.png)