# 5.4 Teleport·传送门

## 作用

### 可以将一个组件的一部分模板“传送”到该组件的 DOM 层次结构之外的 DOM 节点中

## 基本使用

### 有时我们可能会遇到以下情况：组件模板的一部分在逻辑上属于它，但从视图角度来看，在 DOM 中它应该显示在 Vue 应用之外的其他地方

### 举例：模态框

- 理想情况下，我们希望模态框的按钮和模态框本身是在同一个组件中，因为它们都与组件的开关状态有关

- 但这意味着该模态框将与按钮一起呈现，并且位于应用程序的 DOM 更深的层次结构中。在想要通过 CSS 选择器定位该模态框时非常困难

- 试想下面这样的 HTML 结构

	- 代码

	 
- 接下来我们来看看 modal-button 的实现

	- 代码

	```vue
  <script setup>
	  import { ref } from &#39;vue&#39;
	  
	  const open = ref(false)
	  </script>
	  
	  <template>
	    <button @click='open = true'>Open Modal</button>
	  
	    <div v-if='open' class='modal'>
	      <p>Hello from the modal!</p>
	      <button @click='open = false'>Close</button>
	    </div>
	  </template>
	  
	  <style scoped>
	  .modal {
	    position: fixed;
	    z-index: 999;
	    top: 20%;
	    left: 50%;
	    width: 300px;
	    margin-left: -150px;
	  }
	  </style>

	```
- 这个组件中有一个  按钮来触发打开模态框，和一个类名为 .modal 的 ，它包含了模态框的内容和一个用来关闭的按钮

- 当在初始 HTML 结构中使用这个组件时，会有一些潜在的问题：

	- position: fixed 能够相对于视口放置的条件是：没有任何祖先元素设置了 transform、perspective 或者 filter 

	- 如果我们想要用 CSS transform 为祖先节点  设置动画，则会破坏模态框的布局结构

	- 这个模态框的 z-index 被包含它的元素所制约

-  提供了一个更简洁的方式来解决此类问题，使我们无需考虑那么多层 DOM 结构的问题

```vue

  <button @click='open = true'>Open Modal</button>
  
  <Teleport to='body'>
    <div v-if='open' class='modal'>
      <p>Hello from the modal!</p>
      <button @click='open = false'>Close</button>
    </div>
  </Teleport>
```
- 你可以将  和  结合使用来创建一个带动画的模态框

### 为  指定的目标 to 期望接收一个 CSS 选择器字符串或者一个真实的 DOM 节点，其实就是让 Vue 去“传送这部分模板片段到 body 标签下

###  挂载时，传送门的 to 目标必须是已经存在于 DOM 之中。理想情况下，这应该是整个 Vue 应用程序之外的一个元素。如果目标是由 Vue 呈现的另一个元素，你需要确保在  之前挂载该元素

## 搭配组件使用

###  只改变了渲染的 DOM 结构，它不会影响组件间的逻辑关系。这也就是说，如果  包含了一个组件，那么该组件始终和这个使用了  的组件保持逻辑上的父子关系。传入的 props 和触发的事件也会照常工作

### 这也意味着来自父组件的注入也会按预期工作，子组件将在 Vue Devtools 中嵌套在父级组件下面，而不是放在实际内容移动到的地方

## 禁用传送门

### 通过 的 disabled prop控制，Vue会根据它的真假值来决定是否禁用


![5.4Teleport4c7ad4bdbf164223.png](https://img.picgo.net/2024/02/10/5.4Teleport4c7ad4bdbf164223.png)