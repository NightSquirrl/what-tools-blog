---
title: 1. 基础概念
tag:
  -  TypeScript
top: 1
recommend: 1
---

## 基础类型

###  Boolean 类型

```ts
let isDone: boolean = false;
// ES5：var isDone = false;
```

### Number 类型

```ts
let count: number = 10;
// ES5：var count = 10;
```

### String 类型

```ts
let name: string = "semliker";
// ES5：var name = 'semlinker';
```

### Symbol 类型

```ts
const sym = Symbol();
let obj = {

[sym]: "semlinker",

};

console.log(obj[sym]); // semlinker
```

### Array 类型

```ts
let list: number[] = [1, 2, 3];
// ES5：var list = [1,2,3];

let list: Array<number> = [1, 2, 3]; // Array<number>泛型语法
// ES5：var list = [1,2,3];
```

### 💡Enum 类型

#### 数字枚举-常用

```ts
enum Direction {
  NORTH,
  SOUTH,
  EAST,
  WEST,
}

// 默认情况下 NORTH,  SOUTH,  EAST,  WEST,值一次递增
// 也可以自己指定值

enum Direction {
  NORTH = 3, // 设值的是初始的值,后面的值一次递增,也可以给每一个指定
  SOUTH,
  EAST,
  WEST,
}

```

#### 字符串枚举-常用

```ts
enum Direction {
  NORTH = "NORTH",
  SOUTH = "SOUTH",
  EAST = "EAST",
  WEST = "WEST",
}

// 类似于声明对象一样,可以当做类型使用,也可当做值使用
```

> 特殊

```ts
enum Direction {
  NORTH,
  SOUTH,
  EAST,
  WEST,
}

let dirName = Direction[0]; // NORTH
let dirVal = Direction["NORTH"]; // 0

```

#### 异构枚举

> 混合罢了

```ts
enum Enum {
  A,
  B,
  C = "C",
  D = "D",
  E = 8,
  F,
}

```

### 💡Any 类型

在类型报错的地方,或者临时不想指定类型的时候可以暂时使用 any,规范的 ts 项目,最好为每一个类型指定

### Unknown 类型

就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：
```ts
let value: unknown;

value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK

```

### Tuple 类型

==数组一般由同种类型的值组成==，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。

```ts
let tupleType: [string, boolean];
tupleType = ["semlinker", true];

```

### Void 类型

某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：
```ts
// 声明函数返回值为 void
function warnUser(): void {
  console.log("This is my warning message");
}

```

### Null 和 Undefined 类型

==TypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。==

```ts
let u: undefined = undefined;
let n: null = null;

```

> 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。然而，如果你指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自的类型。

### object, Object 和 {} 类型

object 类型是：TypeScript 2.2 引入的新类型，它用于表示非原始类型。

Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义：

Object 接口定义了 Object.prototype 原型对象上的属性；
```ts
// node_modules/typescript/lib/lib.es5.d.ts
interface Object {
  constructor: Function;
  toString(): string;
  toLocaleString(): string;
  valueOf(): Object;
  hasOwnProperty(v: PropertyKey): boolean;
  isPrototypeOf(v: Object): boolean;
  propertyIsEnumerable(v: PropertyKey): boolean;
}

```

#### {} 类型

{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译

```ts
// Type {}
const obj = {};

// Error: Property 'prop' does not exist on type '{}'.
obj.prop = "semlinker";

```

### Never 类型

never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。
```ts
// 返回 never 的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

```

## typescript 断言

通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”
简单的说: 你比 ts 更清楚的知道此处的类型是什么

- 💡“尖括号” 语法

```ts
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```

- 💡as 语法

```ts
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```

- 💡非空断言

  - 💡忽略 undefined 和 null 类型

  ```ts
    // Type 'undefined' is not assignable to type 'string'.
    const ignoreUndefinedAndNull: string = maybeString!; // Ok
  
  ts 觉得 maybeString 可能是空的,但是你知道他不可能为空,所以为了解决 ts 的错误末尾添加!告诉 ts 他不可能为空
  ```

## 类型守卫

### in 关键字

```ts
interface Admin {
  name: string;
  privileges: string[];
}

interface Employee {
  name: string;
  startDate: Date;
}

type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
  console.log("Name: " + emp.name);
  if ("privileges" in emp) {
    console.log("Privileges: " + emp.privileges);
  }
  if ("startDate" in emp) {
    console.log("Start Date: " + emp.startDate);
  }
}
```

判断该字符串"privileges"类型,是否在该类型中

### typeof 关键字

```ts
function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}
```

typeof更像是直接判断类型,判断的值只能是 "number"， "string"， "boolean" 或 "symbol"

### instanceof 关键字

```ts
interface Padder {
  getPaddingString(): string;
}

class SpaceRepeatingPadder implements Padder {
  constructor(private numSpaces: number) {}
  getPaddingString() {
    return Array(this.numSpaces + 1).join(" ");
  }
}

class StringPadder implements Padder {
  constructor(private value: string) {}
  getPaddingString() {
    return this.value;
  }
}

let padder: Padder = new SpaceRepeatingPadder(6);

if (padder instanceof SpaceRepeatingPadder) {
  // padder 的类型收窄为 'SpaceRepeatingPadder'
}
```

### 自定义类型保护的类型谓词

```ts
function isNumber(x: any): x is number {
  return typeof x === "number";
}

function isString(x: any): x is string {
  return typeof x === "string";
}
```

## 联合类型和类型别名

### 联合类型

```ts
// 联合类型就是将多个类型使用 | 组合
// 比如 在声明变量的时候但是并不想给值,或者不知道给值
let a : number | undefined;
```

#### 可辨识-不常用

```ts
enum CarTransmission {
  Automatic = 200,
  Manual = 300,
}

interface Motorcycle {
  vType: "motorcycle"; // discriminant
  make: number; // year
}

interface Car {
  vType: "car"; // discriminant
  transmission: CarTransmission;
}

interface Truck {
  vType: "truck"; // discriminant
  capacity: number; // in tons
}
```

在上述代码中，我们分别定义了 Motorcycle、 Car 和 Truck 三个接口，在这些接口中都包含一个 vType 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。

### 类型别名

```ts
type Message = string | string[];

let greet = (message: Message) => {
  // ...
};
```

## 交叉类型

在 TypeScript 中交叉类型是将多个类型合并为一个类型。==通过&==运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。

```ts
type PartialPointX = { x: number };
type Point = PartialPointX & { y: number };

let point: Point = {
  x: 1,
  y: 1,
};
```

### 同名基础类型属性的合并

```ts
interface X {
  c: string;
  d: string;
}

interface Y {
  c: number;
  e: string;
}

type XY = X & Y;
type YX = Y & X;

let p: XY;
let q: YX;
```

在上面的代码中，接口 X 和接口 Y 都含有一个相同的成员 c，但它们的类型不一致。对于这种情况，此时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 string 或 number 类型呢？

成员 c 的类型会变成 never 呢？这是因为混入后成员 c 的类型为 string & number，即成员 c 的类型既可以是 string 类型又可以是 number 类型。很明显这种类型是不存在的，所以混入后成员 c 的类型为 never。

### 同名非基础类型属性的合并

```typescript
interface D {
  d: boolean;
}
interface E {
  e: string;
}
interface F {
  f: number;
}

interface A {
  x: D;
}
interface B {
  x: E;
}
interface C {
  x: F;
}

type ABC = A & B & C;

let abc: ABC = {
  x: {
    d: true,
    e: "semlinker",
    f: 666,
  },
};

console.log("abc:", abc);
```

由上图可知，在混入多个类型时，若存在相同的成员，且成员类型为非基本数据类型，那么是可以成功合并。

## typescript 函数

|   TypeScript   |     JavaScript     |
| :------------: | :----------------: |
|    含有类型    |       无类型       |
|    箭头函数    | 箭头函数（ES2015） |
|    函数类型    |     无函数类型     |
| 必填和可选参数 | 所有参数都是可选的 |
|    默认参数    |      默认参数      |
|    剩余参数    |      剩余参数      |
|    函数重载    |     无函数重载     |

参数类型以及返回值类型

```ts
let IdGenerator: (chars: string, nums: number) => string;

function createUserId(name: string, id: number): string {
  return name + id;
}
```

### 💡可选参数及默认参数

```ts
// 可选参数
function createUserId(name: string, id: number, age?: number): string {
  return name + id;
}

// 默认参数
function createUserId(
  name: string = "semlinker",
  id: number,
  age?: number
): string {
  return name + id;
}
```

在声明函数时，可以通过 ? 号来定义可选参数，比如 age?: number 这种形式。在实际使用时，==需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。==

### 💡剩余参数

```ts
function push(array, ...items) {
  items.forEach(function (item) {
    array.push(item);
  });
}

let a = [];
push(a, 1, 2, 3);
```

### 函数重载

其实来自于 Java

> 简单的说同一个函数名会根据参数个数不同,参数类型不同掉用不同的函数

函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: string, b: number): string;
function add(a: number, b: string): string;
function add(a: Combinable, b: Combinable) {
  // type Combinable = string | number;
  if (typeof a === "string" || typeof b === "string") {
    return a.toString() + b.toString();
  }
  return a + b;
}
```

方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：

```ts
class Calculator {
  add(a: number, b: number): number;
  add(a: string, b: string): string;
  add(a: string, b: number): string;
  add(a: number, b: string): string;
  add(a: Combinable, b: Combinable) {
    if (typeof a === "string" || typeof b === "string") {
      return a.toString() + b.toString();
    }
    return a + b;
  }
}

const calculator = new Calculator();
const result = calculator.add("Semlinker", " Kakuqo");
```

