---
title: Session
tag:
  - storage
star: true
---

前言:
一般来说,session 的概念存在于后端服务器中,前端基本不需要单独的操作. 知道这一句话也就足够了,再看看优缺点

### 认证流程

Step-1：用户端发起登录请求，发账号密码给服务端

Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法

认证成功 ==服务端==往 `session` 中存入当前用户信息 ，并响应前端请求（response-header:set-cookie(sessionid)）
后端响应前端时会带上 set-cookie 属性，同时将当前 `session` 的唯一ID，放入属性中
前端拿到 `session` ID 后会自动存入到 cookie 中
后续前端每次请求，都会在 request header 的 cookie 中带上唯一的 `session` ID
后端拿到唯一的 `session` ID 就可映射当前 `session` ID 对应的用户信息，以维持用户登录状态
认证失败 发送用户鉴权失败信息给前端

### 优点

后端只要往 Session 里面存入用户信息，不仅限于字符串，对象也可以（容量大）
获取 Session 信息方便，Session ID 唯一映射
Web 服务器端（如tomcat），会在响应头存入 set-cookie 属性，以及当前 session 唯一ID
浏览器检测有响应有set-cookie 属性，会自动存入 cookie 中，前端不需要手动去调用 setCookie() 方法
下一次前端请求会自动带上 cookie 发送给后端
存储在服务器端，安全性大大提高，避免篡改风险

### 缺点

占用服务器资源
扩展性差 （分布式集群）
需要依赖 cookie
跨域限制
小程序不支持 cookie

#### 扩展性差

> 针对后端的集群部署，需要在后端进行 session 的持久化的缺点

1. 当后端压力大时，我们可能对后端进行集群部署，如 192.168.1.101:8001，192.168.1.102:8002，192.168.1.103:8003
2. 此时前端发起登录请求，我们往 session 存入当前 A用户 信息，只会在一台服务器中存储，如 192.168.1.101:8001
3. 其他服务器是没有 A用户 的登录信息的
4. 集群之后的 负载均衡 可能下一次请求就会打到其他服务器上
5. 判定用户没有登录

> 针对跨域的缺点

1. 在当下移动端盛行情况下，我们可能有 网页端 192.168.1.102:8080，移动端 192.168.1.102:8090，小程序端，Android端，Mac端等等 192.168.1.102:XXXX
2. 这些端都会有各自端口和域名，这个时候前端再次请求后端，就会发生跨域问题
3. 跨域情况下 cookie 默认是无法进行传递的
4. 解决思路是 后端设置允许跨域，前端单独设置允许跨越的 cookie 传递 （跨域传递cookie 十分麻烦）