# 8.2 TypeScript 与组合式 API

## 为组件的 prop 标注类型

### 使用  时，`defineProps()` 支持从它的参数中推导类型

```js
<script setup lang='ts'>
const props = defineProps({
  foo: { type: String, required: true },
  bar: Number
})

props.foo // string
props.bar // number | undefined
</script>

```
- 这被称之为“运行时声明”，因为传递给 `defineProps() `的参数会作为运行时的 props 选项使用

### 更直接的方式是通过泛型参数来定义 prop 的类型

```js
<script setup lang='ts'>
const props = defineProps<{
  foo: string
  bar?: number
}>()
</script>
```

- 这被称之为“基于类型的声明”

### 注意，以上两种方式（基于类型的声明或者运行时声明）都可以使用，但是你不能同时使用两者

### 我们也可以将 prop 的类型移入一个单独的接口中

- 代码

```ts
<script setup lang='ts'>
  interface Props {
    foo: string
    bar?: number
  }
  
  const props = defineProps<Props>()
</script>
```

### 语法限制

- 为了生成正确的运行时代码，传给 `defineProps()` 的泛型参数必须是以下之一

- 一个类型字面量

	- `defineProps()`

- 对同一个文件中的一个接口或对象类型字面量的引用

	- 接口或对象字面类型可以包含从其他文件导入的类型引用，但是，传递给 defineProps 的泛型参数本身 不能 是一个导入的类型

	- 这是因为 Vue 组件是单独编译的，编译器目前不会抓取导入的文件以分析源类型。这个限制可能会在未来的版本中被解除

### Prop 默认值

- 当使用基于类型的声明时，我们失去了对 prop 定义默认值的能力。这可以通过目前实验性的响应性语法糖来解决

	- 代码

	 ```js
 <script setup lang='ts'>
	  interface Props {
	    foo: string
	    bar?: number
	  }
	  
	  // 对 defineProps() 的响应性解构
	  // 默认值会被编译为等价的运行时选项
	  const { foo, bar = 100 } = defineProps<Props>()
	  </script>
   ```


### 不使用 

- 如果没有使用 ，开启 prop 的类型推导必须使用 `defineComponent()`。传入 `setup()` 的 prop 对象类型是从 props 选项中推导而来

## 为组件的 emit 标注类型

### 在  中，emit 函数的类型标注可以通过运行时声明或类型声明进行

- 代码

```js
  <script setup lang='ts'>
  // 运行时
  const emit = defineEmits([&#39;change&#39;, &#39;update&#39;])
  
  // 基于类型
  const emit = defineEmits<{
    (e: &#39;change&#39;, id: number): void
    (e: &#39;update&#39;, value: string): void
  }>()
  </script>

```
### 若没有使用 ，`defineComponent()` 也可以根据 emits 选项推导暴露在 setup 上下文中的 emit 函数的类型

- 代码

```js
  import { defineComponent } from &#39;vue&#39;
  
  export default defineComponent({
    emits: [&#39;change&#39;],
    setup(props, { emit }) {
      emit(&#39;change&#39;) // <-- 类型检查 / 自动补全
    }
  })
```
## 为` ref()` 标注类型

### ref 会根据初始化时的值推导其类型

- 代码

 ```js
 import { ref } from &#39;vue&#39;
  
  // 推导出的类型：Ref<number>
  const year = ref(2020)
  
  // => TS Error: Type &#39;string&#39; is not assignable to type &#39;number&#39;.
  year.value = &#39;2020&#39;

 ```
### 有时我们可能想为 ref 内的值指定一个更复杂的类型，可以通过使用 Ref 这个类型，或者，在调用 `ref() `时传入一个泛型参数，来覆盖默认的推导行为

- 代码

 ` import { ref, Ref } from &#39;vue&#39;`
  
  `const year: Ref<string | number> = ref(&#39;2020&#39;)`
  
`  year.value = 2020 // 成功！`
  
  
  
  或者
  
  
 ` // 得到的类型：Ref<string | number>`
  `const year = ref<string | number>(&#39;2020&#39;)`
  
  year.value = 2020 // 成功！
### 如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含 undefined 的联合类型

- 如

 ` // 推导得到的类型：Ref<number | undefined>`
 ` const n = ref<number>()`
## 为 `reactive()` 标注类型

### `reactive()` 也会隐式地从它的参数中推导类型

`import { reactive } from &#39;vue&#39;`

`// 推导得到的类型：{ title: string }`
`const book = reactive({ title: &#39;Vue 3 指引&#39; })`
### 要显式地标注一个 reactive property 的类型，我们可以使用接口

`import { reactive } from &#39;vue&#39;`

`interface Book {`
  `title: string`
  `year?: number`
`}`

`const book: Book = reactive({ title: &#39;Vue 3 指引&#39; })`
## 为 `computed()` 标注类型

### `computed()` 会从其计算函数的返回值上推导出类型

```js

import { ref, computed } from &#39;vue&#39;

const count = ref(0)

// 推导得到的类型：ComputedRef<number>
const double = computed(() => count.value * 2)

// => TS Error: Property &#39;split&#39; does not exist on type &#39;number&#39;
const result = double.value.split(&#39;&#39;)
```
### 还可以通过泛型参数显式指定类型

```js

const double = computed<number>(() => {
  // 若返回值不是 number 类型则会报错
})
```
## 为事件处理器标注类型

### 在处理原生 DOM 事件时，应该为传递给事件处理器的参数正确地标注类型

```js
<script setup lang='ts'>
function handleChange(event) {
  // `event` 隐式地标注为 `any` 类型
  console.log(event.target.value)
}
</script>

<template>
  <input type='text' @change='handleChange' />
</template>

```
- 没有类型标注时，这个 event 参数会隐式地标注为 any 类型。也会在 tsconfig.json 配置了 "strict": true 或 "noImplicitAny": true 时报出一个 TS 错误

- 建议显式地为事件处理器的参数标注类型

## 为 provide/inject 标注类型

### provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 InjectionKey 接口，它是一个继承自 Symbol 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型

```js

import { provide, inject, InjectionKey } from &#39;vue&#39;

const key = Symbol() as InjectionKey<string>

provide(key, &#39;foo&#39;) // 若提供的是非字符串值会导致错误

const foo = inject(key) // foo 的类型：string | undefined
```
### 当使用字符串注入 key 时，注入值的类型是 unknown，需要通过泛型参数显式声明

## 为模板 ref 标注类型

### 模板 ref 需要通过一个显式指定的泛型参数和一个初始值 null 来创建

- 代码

```js

  <script setup lang='ts'>
  import { ref, onMounted } from &#39;vue&#39;
  
  const el = ref<HTMLInputElement | null>(null)
  
  onMounted(() => {
    el.value?.focus()
  })
  </script>
  
  <template>
    <input ref='el' />
  </template>
```
### 注意为了严格的类型安全，有必要在访问 el.value 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 ref 的值都是初始的 null，并且在由于 v-if 的行为将引用的元素卸载时也可以被设置为 null

## 为组件模板 ref 标注类型

### 有时，你可能需要为一个子组件添加一个模板 ref，以便调用它公开的方法

- 例如

  我们有一个 MyModal 子组件，它有一个打开模态框的方法：
  
  <!-- MyModal.vue -->
```js

  <script setup lang='ts'>
  import { ref } from &#39;vue&#39;
  
  const isContentShown = ref(false)
  const open = () => (isContentShown.value = true)
  
  defineExpose({
    open
  })
  </script>
```
	- 为了获取 MyModal 的类型，我们首先需要通过 typeof 得到其类型，再使用 TypeScript 内置的 InstanceType 工具类型来获取其实例类型

	  <!-- App.vue -->
```js

	  <script setup lang='ts'>
	  import MyModal from &#39;./MyModal.vue&#39;
	  
	  const modal = ref<InstanceType<typeof MyModal> | null>(null)
	  
	  const openModal = () => {
	    modal.value?.open()
	  }
	  </script>
```
- 注意，如果你想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的托管模式


![8.2TypeScript--APIfed69b321a383131.png](https://img.picgo.net/2024/02/10/8.2TypeScript--APIfed69b321a383131.png)