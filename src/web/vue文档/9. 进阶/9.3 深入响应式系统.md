# 9.3 深入响应式系统

## 什么是 Vue 的响应性

### 简单来说就是，Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM

## Vue 中的响应性是如何工作的

### 在JS中可以追踪一个对象的属性进行读和写的来实现响应式

### 在 JavaScript 中有两种劫持属性访问的方式：getter/setters 和 Proxies

- Vue 2 使用 getter/setters 完全由于需支持更旧版本浏览器的限制

```js
  function reactive(obj) {
    return new Proxy(obj, {
      get(target, key) {
        track(target, key)
        return target[key]
      },
      set(target, key, value) {
        trigger(target, key)
        target[key] = value
      }
    })
  }
```
- Vue 3 中使用了 Proxy 来创建响应式对象，将 getter/setter 用于 ref

 ```js
 function ref(value) {
    const refObject = {
      get value() {
        track(refObject, &#39;value&#39;)
        return value
      },
      set value(newValue) {
        trigger(refObject, &#39;value&#39;)
        value = newValue
      }
    }
    return refObject
  }
 ```
### 在获取值时，都会执行track函数，在 `track()` 内部，我们会检查当前是否有正在运行的副作用。如果有，我们会查找到一个所有追踪了该属性的订阅者，它们存储在一个 Set 中，然后将当前这个副作用添加到该 Set 中。副作用订阅将被存储在一个全局的 WeakMap>> 数据结构中。如果在第一次追踪时没有找到对相应属性订阅的副作用集合，它将会在这里新建。这就是 `getSubscribersForProperty()` 函数所做的事

```js
// 这会在一个副作用就要运行之前被设置
// 我们会在后面处理它
let activeEffect

function track(target, key) {
  if (activeEffect) {
    const effects = getSubscribersForProperty(target, key)
    effects.add(activeEffect)
  }
}
```
### 在修改值时，会执行trigger函数，在 trigger() 之中，我们会再查找到该属性的所有订阅副作用。但这一次我们是去调用它们

```js

function trigger(target, key) {
  const effects = getSubscribersForProperty(target, key)
  effects.forEach((effect) => effect())
}
```
### whenDepsChange() 函数中

```js
function whenDepsChange(update) {
  const effect = () => {
    activeEffect = effect
    update()
    activeEffect = null
  }
  effect()
}
```
- 它包装了原先的 update 函数到一个副作用中，并在运行实际的更新之前，将它自己设为当前活跃的副作用。而在更新期间开启的 `track()` 调用，都将能定位到这个当前活跃的副作用

- 此时，我们已经创建了一个能自动跟踪其依赖关系的副作用，它会在依赖关系更改时重新运行。我们称其为响应式副作用

### Vue 提供了一个 API 来让你创建响应式副作用 `watchEffect()`。事实上，你会发现它的使用方式和我们上面示例中说的魔法函数 `whenDepsChange()` 非常相似。我们可以用真正的 Vue API 改写上面的例子

```js
import { ref, watchEffect } from &#39;vue&#39;

const A0 = ref(0)
const A1 = ref(1)
const A2 = ref()

watchEffect(() => {
  // 追踪 A0 和 A1
  A2.value = A0.value + A1.value
})

// 将触发副作用
A0.value = 2

```
### 常见的响应式副作用的用例是什么呢？自然是更新 DOM！我们可以像下面这样实现一个简单的“响应式渲染”

```js

import { ref, watchEffect } from &#39;vue&#39;

const count = ref(0)

watchEffect(() => {
  document.body.innerHTML = `计数：${count.value}`
})

// 更新 DOM
count.value++
```
## 运行时 vs. 编译时响应性

### Vue 的响应式系统基本是基于运行时的。追踪和触发都是在浏览器中运行时进行的。运行时响应性的优点是，它可以在没有构建步骤的情况下工作，而且边缘情况较少。另一方面，这使得它受到了 JavaScript 语法的制约

```js
<div v-color='color'></div>
app.directive(&#39;color&#39;, (el, binding) => {
  // 这会在 `mounted` 和 `updated` 时都调用
  el.style.color = binding.value
})

```
### JavaScript 并没有提供一种方式来拦截对局部变量的读写，因此我们始终只能够以对象属性的形式访问响应式状态，也就因此有了响应式对象和 ref

## 响应性调试

### 组件调试钩子

- 我们可以在一个组件渲染时调试查看哪些依赖正在被使用，以及使用 onRenderTracked 和 onRenderTriggered 生命周期钩子来确定哪个依赖正在触发更新。这些钩子都会收到一个调试事件，其中包含了所需依赖的信息。推荐在回调中放置一个 debugger 语句，使你可以在开发者工具中交互式地查看依赖
```js

  <script setup>
  import { onRenderTracked, onRenderTriggered } from &#39;vue&#39;
  
  onRenderTracked((event) => {
    debugger
  })
  
  onRenderTriggered((event) => {
    debugger
  })
  </script>

```
- 调试事件对象有如下的类型定义

```ts
  type DebuggerEvent = {
    effect: ReactiveEffect
    target: object
    type:
      | TrackOpTypes /* &#39;get&#39; | &#39;has&#39; | &#39;iterate&#39; */
      | TriggerOpTypes /* &#39;set&#39; | &#39;add&#39; | &#39;delete&#39; | &#39;clear&#39; */
    key: any
    newValue?: any
    oldValue?: any
    oldTarget?: Map<any, any> | Set<any>
  }
```
### 计算属性调试

- 可以向 `computed() `传入第二个参数，是一个包含了 onTrack 和 onTrigger 两个回调函数的对象

	- onTrack 将在响应属性或引用作为依赖项被跟踪时被调用

	- onTrigger 将在侦听器回调被依赖项的变更触发时被调用

	- 注：这两个回调都会作为组件组件调试的钩子，接受相同格式的调试事件

### 侦听器调试

- 和 `computed() `类似，侦听器也支持 onTrack 和 onTrigger 选项

```ts
  watch(source, callback, {
    onTrack(e) {
      debugger
    },
    onTrigger(e) {
      debugger
    }
  })
  
  watchEffect(callback, {
    onTrack(e) {
      debugger
    },
    onTrigger(e) {
      debugger
    }
  })
```
### 注意：组件调试钩子、以及计算属性和侦听器的 onTrack 和 onTrigger 选项仅会在开发模式下工作

## 与其他状态系统集成

### Vue 的响应性系统是通过深度转换纯 JavaScript 对象到响应式代理来实现的。这种深度转换可以是不必要的，或者在集成其他外部状态管理系统时甚至是我们不想要的。将 Vue 的响应性系统与外部状态管理方案集成的总体意见是：将外部状态放在一个 shallowRef 中。一个浅层的 ref 中只有它的 .value 属性本身被访问时才是有响应性的，而不关心它内部的值。当外部状态改变时，替换此 ref 的 .value 才会触发更新

### 不可变数据

- 如果你正在实现一个撤销/重做的功能，你可能想要对用户编辑时应用的状态进行快照记录。然而，如果状态树很大的话，Vue 的可变响应性系统没法很好地处理这种情况，因为在每次更新时都序列化整个状态对象对 CPU 和内存开销来说都是非常昂贵的

- 不可变数据结构通过永不更改状态对象来解决这个问题。与 Vue 不同的是，它会创建一个新对象，保留旧的对象未发生改变的一部分。在 JavaScript 中有多种不同的方式来使用不可变数据，但我们推荐使用 Immer 搭配 Vue，因为它使你可以在保持原有直观、可变的语法的同时，使用不可变数据

- 例如：我们可以通过一个简单的可组合函数来集成 Immer

```js
  import produce from &#39;immer&#39;
  import { shallowRef } from &#39;vue&#39;
  
  export function useImmer(baseState) {
    const state = shallowRef(baseState)
    const update = (updater) => {
      state.value = produce(state.value, updater)
    }
  
    return [state, update]
  }

```
### 状态机

- 状态机是一种数据模型，用于描述应用程序可能处于的所有可能状态，以及从一种状态转换到另一种状态的所有可能方式。虽然对于简单的组件来说，这可能有些小题大做了，但它的确可以使得复杂的状态流更加健壮和易于管理

- JavaScript 中一个最受欢迎的状态机实现方案就是 XState。这里是集成它的一个例子

```js
  import { createMachine, interpret } from &#39;xstate&#39;
  import { shallowRef } from &#39;vue&#39;
  
  export function useMachine(options) {
    const machine = createMachine(options)
    const state = shallowRef(machine.initialState)
    const service = interpret(machine)
      .onTransition((newState) => (state.value = newState))
      .start()
    const send = (event) => service.send(event)
  
    return [state, send]
  }
```
### RxJS

- RxJS 是否有一个用于处理异步事件流的库。VueUse 库提供了 @vueuse/rxjs 扩展来支持连接 RxJS 流与 Vue 的响应性系统


![9.3a972bdc374169c40.png](https://img.picgo.net/2024/02/10/9.3a972bdc374169c40.png)