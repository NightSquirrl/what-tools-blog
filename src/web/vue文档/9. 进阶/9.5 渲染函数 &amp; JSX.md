# 9.5 渲染函数 &amp; JSX

## 基本用法

### 创建 Vnodes

- Vue 提供了一个 `h()` 函数用于创建 vnodes

- `h()` 是 hyperscript 的简称——意思是 "能生成 HTML (超文本标记语言) 的 JavaScript"。这个名字来源于许多虚拟 DOM 实现时共享的约定。 一个更准确的名称应该是 `createVnode()` ， 但当你需要多次使用渲染函数时，一个简短的名字能更好地帮到你

- `h()` 函数的使用方式非常的灵活

	- 例如

	 ```js
    // 除了类型必填以外，其他的参数都是可选的
	  h(&#39;div&#39;)
	  h(&#39;div&#39;, { id: &#39;foo&#39; })
	  
	  // attribute 和 property 都能在 prop 中书写
	  // Vue 会自动将它们分配到正确的位置
	  h(&#39;div&#39;, { class: &#39;bar&#39;, innerHTML: &#39;hello&#39; })
	  
	  // 类与样式可以像在模板中一样
	  // 用数组或对象的形式书写
	  h(&#39;div&#39;, { class: [foo, { bar }], style: { color: &#39;red&#39; } })
	  
	  // 事件监听器应以 onXxx 的形式书写
	  h(&#39;div&#39;, { onClick: () => {} })
	  
	  // children 可以是一个字符串
	  h(&#39;div&#39;, { id: &#39;foo&#39; }, &#39;hello&#39;)
	  
	  // 没有 props 时可以省略不写
	  h(&#39;div&#39;, &#39;hello&#39;)
	  h(&#39;div&#39;, [h(&#39;span&#39;, &#39;hello&#39;)])
	  
	  // children 数组可以同时包含 vnodes 与字符串
	  h(&#39;div&#39;, [&#39;hello&#39;, h(&#39;span&#39;, &#39;hello&#39;)])
   ```
### 声明渲染函数

- 当组合式 API 与模板一起使用时,` setup() `钩子的返回值是用于暴露数据给模板。 然而当我们使用渲染函数时，可以直接把渲染函数返回

```js
  import { ref, h } from &#39;vue&#39;
  
  export default {
    props: {
      /* ... */
    },
    setup(props) {
      const count = ref(1)
  
      // 返回渲染函数
      return () => h(&#39;div&#39;, props.msg + count.value)
    }
  }

```
- 在` setup() `内部声明的渲染函数天生能够访问在同一范围内声明的 props 和许多响应式状态

- 除了返回一个 vnode ，你还可以返回字符串或数组

```js
  export default {
    setup() {
      return () => &#39;hello world!&#39;
    }
  }
  import { h } from &#39;vue&#39;
  
  export default {
    setup() {
      // 使用数组返回多个根节点
      return () => [
        h(&#39;div&#39;),
        h(&#39;div&#39;),
        h(&#39;div&#39;)
      ]
    }
  }

```
- 请确保返回的是一个函数而不是一个值！` setup()` 函数在每个组件中只会被调用一次，而返回的渲染函数将会被调用多次

- 如果一个渲染函数组件不需要任何实例状态，为了简洁起见，它们也可以直接被声明为一个函数

	- `function Hello() { return 'hello world!'}`

### Vnodes 必须唯一

- 组件树中的 vnodes 必须是唯一的

- 如果你真的非常想在页面上渲染多个重复的元素或者组件， 你可以使用一个工厂函数来做这件事。 比如渲染函数渲染出20个相同的段落

```js
  function render() {
    return h(
      &#39;div&#39;,
      Array.from({ length: 20 }).map(() => {
        return h(&#39;p&#39;, &#39;hi&#39;)
      })
    )
  }

```
## JSX / TSX

### JSX 是 JavaScript 的一个类似 XML 的扩展，有了它，我们可以用一下的方式来书写代码

- `const vnode = hello`

### 在 JSX 表达式中，使用大括号来嵌入动态值

- `const vnode = hello, {userName}`

### create-vue 和 Vue CLI 都有预置的 JSX 语法支持。 如果你想手动配置 JSX ， 请参阅 @vue/babel-plugin-jsx 文档获取更多细节

### Vue 的类型定义也提供了 TSX 语法的类型推断支持。当使用 TSX 语法时， 确保在 tsconfig.json 中配置了 "jsx": "preserve" ， 这样的 TypeScript 就能保证 Vue JSX 语法编译过程中的完整性

## 渲染函数案例

### v-if

- 模板

```html
  <div>
    <div v-if='ok'>yes</div>
    <span v-else>no</span>
  </div>
```
	- 等价于使用如下渲染函数 / JSX 语法

```vue

    h(&#39;div&#39;, [ok.value ? h(&#39;div&#39;, &#39;yes&#39;) : h(&#39;span&#39;, &#39;no&#39;)])
	  
	  
	  <div>{ok.value ? <div>yes</div> : <span>no</span>}</div>
```
### v-for

- 模板

```vue
  <ul>
    <li v-for='{ id, text } in items' :key='id'>
      {{ text }}
    </li>
  </ul>
```
	- 等价于使用如下渲染函数 / JSX 语法

```vue
	  h(
	    &#39;ul&#39;,
	    // assuming `items` is a ref with array value
	    items.value.map(({ id, text }) => {
	      return h(&#39;li&#39;, { key: id }, text)
	    })
	  )
	  
	  <ul>
	    {items.value.map(({ id, text }) => {
	      return <li key={id}>{text}</li>
	    })}
	  </ul>
```
### v-on

- 以 on 开头，并跟着大写字母的 props 会被当作事件监听器

```vue
  h(
    &#39;button&#39;,
    {
      onClick(event) {
        /* ... */
      }
    },
    &#39;click me&#39;
  )
  <button
    onClick={(event) => {
      /* ... */
    }}
  >
    click me
  </button>
```
### 事件修饰符

- 对于 .passive 、.capture 和 .once 事件修饰符，可以使用驼峰写法将他们拼接在事件名后面

  ```vue
h(&#39;input&#39;, {
    onClickCapture() {
      /* 捕捉模式中的监听器 */
    },
    onKeyupOnce() {
      /* 只触发一次 */
    },
    onMouseoverOnceCapture() {
      /* 单次 + 捕捉 */
    }
  })
  <input
    onClickCapture={() => {}}
    onKeyupOnce={() => {}}
    onMouseoverOnceCapture={() => {}}
  />
  ```
- 对于事件和按键修饰符，可以使用 withModifiers 函数

```vue
  import { withModifiers } from &#39;vue&#39;
  
  h(&#39;div&#39;, {
    onClick: withModifiers(() => {}, [&#39;self&#39;])
  })
  <div onClick={withModifiers(() => {}, [&#39;self&#39;])} />
```
### 组件

- 在给组件创建 vnode 时， 传递给 `h()` 函数的第一个参数应当是组件的定义。 这意味着使用渲染函数时不再需要注册组件了 —— 可以直接使用导入的组件

 ```vue
 import Foo from &#39;./Foo.vue&#39;
  import Bar from &#39;./Bar.jsx&#39;
  
  function render() {
    return h(&#39;div&#39;, [h(Foo), h(Bar)])
  }
  function render() {
    return (
      <div>
        <Foo />
        <Bar />
      </div>
    )
  }
 ```
- 动态组件在渲染函数中也可直接使用

 ```vue
 import Foo from &#39;./Foo.vue&#39;
  import Bar from &#39;./Bar.jsx&#39;
  
  function render() {
      return ok.value ? h(Foo) : h(Bar)
  }
  function render() {
    return ok.value ? <Foo /> : <Bar />
  }
 ```
- 如果一个组件是用名字注册的，不能直接导入（例如，由一个库全局注册）， 可以使用 `resolveComponent()` 来解决这个问题

### 渲染插槽

- 在渲染函数中， 插槽可以通过 `setup() `的上下文来访问。 每个 slots 对象中的插槽都是一个 返回 vnodes 数组的函数

```vue
  export default {
    props: [&#39;message&#39;],
    setup(props, { slots }) {
      return () => [
        // 默认插槽：
        // <div><slot /></div>
        h(&#39;div&#39;, slots.default()),
  
        // 具名插槽：
        // <div><slot name='footer' :text='message' /></div>
        h(
          &#39;div&#39;,
          slots.footer({
            text: props.message
          })
        )
      ]
    }
  }
```
- 等价 JSX 语法

 ```vue
 // 默认插槽
  <div>{slots.default()}</div>
  
  // 具名插槽
  <div>{slots.footer({ text: props.message })}</div>
 ```
### 传递插槽

- 向组件传递子元素的方式与向元素传递子元素的方式有些许不同。我们需要传递一个插槽函数或者是一个包含插槽函数的对象而非是数组， 插槽函数的返回值同一个正常的渲染函数的返回值一样 —— 并且在子组件中被访问时总是会被转化为一个 vnodes 数组

```vue
  // 单个默认插槽
  h(MyComponent, () => &#39;hello&#39;)
  
  // 具名插槽
  // 注意 `null` 是必需的
  // 以避免 slot 对象被当成 prop 处理
  h(MyComponent, null, {
      default: () => &#39;default slot&#39;,
      foo: () => h(&#39;div&#39;, &#39;foo&#39;),
      bar: () => [h(&#39;span&#39;, &#39;one&#39;), h(&#39;span&#39;, &#39;two&#39;)]
  })

```
- 等价 JSX 语法

```vue
  // 默认插槽
  <MyComponent>{() => &#39;hello&#39;}</MyComponent>
  
  // 具名插槽
  <MyComponent>{{
    default: () => &#39;default slot&#39;,
    foo: () => <div>foo</div>,
    bar: () => [<span>one</span>, <span>two</span>]
  }}</MyComponent>

```
### 内置组件

- 诸如  ,  ,  ,  和  等内置组件在渲染函数中必须导入才能使用

```vue

  import { h, KeepAlive, Teleport, Transition, TransitionGroup } from &#39;vue&#39;
  
  export default {
    setup () {
      return () => h(Transition, { mode: &#39;out-in&#39; }, /* ... */)
    }
  }
```
### v-model

- v-model 指令扩展为 modelValue 和 onUpdate:modelValue 在模板编译过程中，我们必须自己提供这些 props

  ```vue
    export default {
    props: [&#39;modelValue&#39;],
    emits: [&#39;update:modelValue&#39;],
    setup(props, { emit }) {
      return () =>
        h(SomeComponent, {
          modelValue: props.modelValue,
          &#39;onUpdate:modelValue&#39;: (value) => emit(&#39;update:modelValue&#39;, value)
        })
    }
  }
  ```
### 自定义指令

- 可以使用 withDirectives 将自定义指令应用于 VNode

```vue
  import { h, withDirectives } from &#39;vue&#39;
  
  // 自定义指令
  const pin = {
    mounted() { /* ... */ },
    updated() { /* ... */ }
  }
  
  // <div v-pin:top.animate='200'></div>
  const vnode = withDirectives(h(&#39;div&#39;), [
    [pin, 200, &#39;top&#39;, { animate: true }]
  ])
```
- 当一个指令是以名称注册并且不能被直接导入时，可以使用 resolveDirective 函数来解决这个问题

## 函数式组件

### 函数式组件是自身没有任何状态的组件的另一种形式。它们在渲染过程中不会创建组件实例，并跳过常规的组件生命周期

### 我们使用的是一个简单函数，来创建函数式组件。 该函数实际上就是该组件的 render 函数

### 函数式组件的签名与 setup() 钩子相同

- `function MyComponent(props, { slots, emit, attrs }) {...}`

### 大多数常规组件的配置选项在函数式组件中都不可用。然而我们还是可以把 props 和 emits 作为 property 加入，以达到定义它们的目的

`MyComponent.props = [&#39;value&#39;]`
`MyComponent.emits = [&#39;click&#39;]`
### 如果这个 props 选项没有被定义，那么被传入函数的 props 对象就会像 attrs 一样会包含所有 attribute。除非指定了 props 选项，否则每个 prop 的名字将不会基于驼峰命名法被一般化处理

### 函数式组件可以像普通组件一样被注册和消费。如果你将一个函数作为第一个参数传入 h ，它将会被当作一个函数式组件来对待


![9.5--JSX1d8ae926042f459f.png](https://img.picgo.net/2024/02/10/9.5--JSX1d8ae926042f459f.png)