# 服务端渲染 (SSR)

## 总览

### 什么是 SSR？

- Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue 组件在浏览器中生成和操作 DOM 作为输出。然而，我们也可以将相同的组件在服务端渲染成 HTML 字符串，直接返回给浏览器，最后再将静态的 HTML “激活” (hydrate) 为完全交互式的客户端应用

- 一个由服务端渲染的 Vue.js 应用也可以被认为是“同构的”或“通用的”，因为应用的大部分代码同时运行在服务端和客户端

### 为什么要用 SSR？

- 优势

	- 更快的内容到达时间

	- 统一的心智模型

	- 更好的 SEO

- 权衡之处

	- 开发中的限制

	- 更多的与构建配置和部署相关的要求

	- 更高的服务端负载

	- 小结：在为你的应用使用 SSR 之前，你首先应该问自己是否真的需要它。这主要取决于内容到达时间对应用的重要程度

### SSR vs. SSG

- 静态站点生成 (SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来就重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管

- SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的内容到达耗时性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是静态：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署

- 如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 /、/about 和 /contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客

## 基本教程

### 渲染一个应用的步骤

- 创建一个新目录并 cd 进入其中

- 运行 npm init -y

- 添加 "type": "module" 到 package.json 中，这样 Node.js 就会以 ESM 模式运行

- 运行 npm install vue

- 创建一个 example.js 文件：

	- 文件内容
```js
	  // 这会用 Node.js 运行在服务器上
	  import { createSSRApp } from &#39;vue&#39;
	  // Vue 的服务端渲染 API 都暴露在 `vue/server-renderer` 之下
	  import { renderToString } from &#39;vue/server-renderer&#39;
	  
	  const app = createSSRApp({
	    data: () => ({ count: 1 }),
	    template: `<button @click='count++'>{{ count }}</button>`
	  })
	  
	  renderToString(app).then((html) => {
	    console.log(html)
	  })
	  ```
- 接着运行：node example.js

	- 它应该会在命令行中打印出如下内容：1

- 然后我们可以将 Vue SSR 代码移到服务器请求处理器中，它将应用程序的标记与整个页面的 HTML 包装起来。我们将在下一步中使用 express

- 运行 npm install express

- 创建下面这样的 server.js 文件：


	- 文件内容
```js
	  import express from &#39;express&#39;
	  import { createSSRApp } from &#39;vue&#39;
	  import { renderToString } from &#39;vue/server-renderer&#39;
	  
	  const server = express()
	  
	  server.get(&#39;/&#39;, (req, res) => {
	    const app = createSSRApp({
	      data: () => ({ count: 1 }),
	      template: `<button @click='count++'>{{ count }}</button>`
	    })
	  
	    renderToString(app).then((html) => {
	      res.send(`
	      <!DOCTYPE html>
	      <html>
	        <head>
	          <title>Vue SSR Example</title>
	        </head>
	        <body>
	          <div id='app'>${html}</div>
	        </body>
	      </html>
	      `)
	    })
	  })
	  
	  server.listen(3000, () => {
	    console.log(&#39;ready&#39;)
	  })
	  ```
- 最后，运行 node server.js 并访问 http://localhost:3000。你将最终能看到页面上按钮可以正常工作了

### 客户端激活

- 如果你点击这个按钮，你会发现数字并没有变化。这是由于我们没有在浏览器中加载 Vue，所以 HTML 在客户端是完全静态的

- 要让客户端应用重新恢复可交互，Vue 需要执行一步 激活 操作。在激活期间，它将创建与服务器上运行的相同的 Vue 应用程序，将每个组件与它应该控制的 DOM 节点相匹配，并附加了 DOM 事件监听器

- 要按激活模式挂载一个应用，我们需要使用 `createSSRApp()` 而不是 `createApp()：`

	- 代码
```js
	  // 该文件运行在浏览器中
	  import { createSSRApp } from &#39;vue&#39;
	  
	  const app = createSSRApp({
	    // ...和服务器上相同的应用配置
	  })
	  
	  // 在客户端挂载 SSR 应用程序时，
	  // 假定 HTML 是预先渲染的，
	  // 并将执行激活而不是安装新的 DOM 节点。
	  app.mount(&#39;#app&#39;)
	  ```
### 代码结构

- 你可能注意到了这里需要重复使用与服务器上相同的应用实现。因此需要开始考虑如何改善 SSR 应用的代码结构——我们如何在服务器和客户端之间共享相同的应用代码？

- 这里将演示最原始的设置。首先，让我们把应用程序的创建逻辑分成一个专门的文件 app.js：

	- 代码
```js
	  // app.js（服务器和客户端之间共享）
	  import { createSSRApp } from &#39;vue&#39;
	  
	  export function createApp() {
	    return createSSRApp({
	      data: () => ({ count: 1 }),
	      template: `<div @click='count++'>{{ count }}</div>`
	    })
	  }
	  ```
- 该文件及其依赖项在服务器和客户端之间共享——我们称它们为 通用代码。编写通用代码时需要注意许多事项

- 我们在客户端入口导入通用代码，创建应用程序并执行挂载：

	- 代码
```js
	  // client.js
	  import { createApp } from &#39;./app.js&#39;
	  
	  createApp().mount(&#39;#app&#39;)
	  ```
- 服务器在请求处理函数中使用相同的应用创建逻辑：

	- 代码
```js
	  // server.js (不相关的代码省略)
	  import { createApp } from &#39;./app.js&#39;
	  
	  server.get(&#39;/&#39;, (req, res) => {
	    const app = createApp()
	    renderToString(app).then(html => {
	      // ...
	    })
	  })
	  ```
- 此外，为了在浏览器中加载客户端文件，我们还需要：

	- 在 server.js 中添加 `server.use(express.static('.'))` 来托管客户端文件

	- 将  添加到 HTML 外壳以加载客户端入口文件

	- 通过在 HTML 外壳中添加 Import Map 以支持在浏览器中使用 `import * from 'vue'`

## 更高阶解决方案

### 推荐几个 Vue 生态中的 SSR 解决方案

- Nuxt

- Quasar

- Vite SSR

## 书写 SSR 友好的代码

### 服务端的响应性

- 在 SSR 期间，每一个请求 URL 都会映射到我们应用中的一个期望状态。因为没有用户交互和 DOM 更新，所以响应性在服务端是不必要的。为了更好的性能，默认情况下响应性在 SSR 期间是禁用的

### 组件生命周期钩子

- 因为没有任何动态更新，所以像 onMounted 或者 onUpdated 这样的生命周期钩子不会在 SSR 期间被调用，并且只会在客户端运行

### 访问平台特有 API

- 通用代码不能访问平台特有的 API，如果你的代码直接使用了浏览器特有的全局变量，比如 window 或 document，他们会在 Node.js 运行时报错，反过来也一样

### 跨请求状态污染

- 在 SSR 环境下，应用模块通常只在服务器启动时初始化一次。同一个应用模块会在多个服务器请求之间被复用，而我们的单例状态对象也一样。如果我们用单个用户特定的数据对共享的单例状态进行修改，那么这个状态可能会意外地泄露给另一个用户的请求。我们把这种情况称为跨请求状态污染

### 激活异常

- 如果预渲染的 HTML 的 DOM 结构不符合客户端应用的期望，就会出现激活异常。在大多数场景中，这是由于浏览器原生的 HTML 解析行为试图纠正 HTML 字符串中的非法结构

### 自定义指令

- 因为大多数的自定义指令都包含了对 DOM 的直接操作，所以它们会在 SSR 时被忽略。但如果你想要自己控制一个自定义指令在 SSR 时应该如何被渲染 (即应该在渲染的元素上添加哪些 attribute)，你可以使用 getSSRProps 指令钩子

![6.6-SSRac11b8f2bbb55382.png](https://img.picgo.net/2024/02/10/6.6-SSRac11b8f2bbb55382.png)