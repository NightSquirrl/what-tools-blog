# 5.3 KeepAlive

## 基本使用

### 默认情况下，一个正活跃的组件实例会在切走后被卸载。这会导致它丢失其中所有的状态变化

### 使我们可以在动态切换多个组件时视情况缓存组件实例

-   

## 包含 / 排除

### 默认情况下， 会不作区分地缓存它之中任何组件

### 但我们可以通过 include 和 exclude prop 来定制该行为。这两个 prop 的值都是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两个类型的一个数组

### 匹配的根据是组件的 name 选项，所以要想通过 KeepAlive 有条件地缓存的组件必须显式声明一个 name 选项

## 最大缓存实例

### 我们可以通过传入 max prop 来限制组件缓存的最大数量

### 当指定了 max 时， 会像一个 LRU 缓存：如果缓存实例的数量即将超过指定的最大数量，最近访问次数最少的缓存实例将被销毁，以便为新的实例腾出空间

## 缓存实例的生命周期

### 当一个组件实例从 DOM 上移除但因为被  缓存而仍作为组件树的一部分时，它将变为不活跃状态而不是被卸载。当一个组件实例作为缓存树的一部分插入到 DOM 中时，它就是被重新恢复活跃了

### 一个持续存在的组件可以通过 onActivated() 和 onDeactivated() 注册相应的两个状态的生命周期钩子

### 注意：

- onActivated 在组件挂载时也会调用，并且 onDectivated 在组件卸载时也会调用

- 这两个钩子不仅适用于  缓存的根组件，也适用于缓存树中的后代组件


![5.3KeepAlive50e8dc62691f4a27.png](https://img.picgo.net/2024/02/10/5.3KeepAlive50e8dc62691f4a27.png)