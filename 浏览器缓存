# 浏览器缓存相关的知识

浏览器缓存主要有以下几个优点：

1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。
2. 降低服务器的压力，提升网站性能。
3. 加快客户端加载网页的速度， 提升用户体验。


## 强缓存和协商缓存

如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。
在 `chrome` 中强缓存（虽然没有发出真实的 `http` 请求）的请求状态码返回是 `200 (from cache)`；而协商缓存如果命中走缓存的话，请求的状态码是 `304 (not modified)`。 不同浏览器的策略不同，在 Fire Fox中，`from cache` 状态码是 `304`.

![案例](https://user-images.githubusercontent.com/11473889/57010212-249bda80-6c2e-11e9-8500-afe8c449e35f.png)

### 请求流程

浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：


1. 浏览器会获取该缓存资源的 `header` 中的信息，根据 `response` `header` 中的 `expires` 和 `cache-control` 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。
    1. 如果`cache-control`对应的值是`no-cache`那就是没有缓存
2. 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified或者 Etag，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。

![案例](https://user-images.githubusercontent.com/11473889/57010205-16e65500-6c2e-11e9-8334-ce884274e529.png)

### 强缓存

强缓存是根据返回头中的 `Expires` 或者 `Cache-Control` 两个字段来控制的，都是表示资源的缓存有效时间。

- `Expires` 是 http 1.0 的规范，值是一个GMT 格式的时间点字符串，比如 `Expires:Mon,18 Oct 2066 23:59:59 GMT` 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 `Expires` 在实际使用中会带来一些麻烦。
- `Cache-Control`这个字段是 `http 1.1` 的规范，一般常用该字段的 max-age 值来进行判断，它是一个相对时间，比如 `Cache-Control:max-age=3600` 代表资源的有效期是 `3600` 秒。并且返回头中的 `Date` 表示消息发送的时间，表示当前资源在 `Date ~ Date +3600s` 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 max-age 之后，在 `max-age` 时间内重新访问资源却会返回 `304 not modified` ，这是由于服务器的时间与本地的时间不同造成的。当然 `Cache-Control` 还有其他几个值可以设置， 不过相对来说都很少用了：

    - `no-cache` 不使用本地缓存。需要使用协商缓存。
    - `no-store`直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 network 中的 disabled cache。
    - `public` 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
    - `private` 只能被终端用户的浏览器缓存。

如果 `Cache-Contro`l与 `Expires` 同时存在的话， `Cache-Control` 的优先级高于 `Expires` 。

### 协商缓存


协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, `Last-Modified` 或者` Etag`，则后续请求则会带上对应的请求字段 `If-Modified-Since`或者 `If-None-Match`，若响应头没有` Last-Modified` 或者 `Etag` 字段，则请求头也不会有对应的字段。

- `Last-Modified/If-Modified-Since` 二者的值都是 `GMT` 格式的时间字符串， `Last-Modified` 标记最后文件修改时间， 下一次请求时，请求头中会带上 `If-Modified-Since` 值就是 `Last-Modified` 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 `304 Not Modified` ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 `304 Not Modified` 的响应时，`response header` 中不会再添加的` Last-Modified` 去试图更新本地缓存的 `Last-Modified`， 因为既然资源没有变化，那么` Last-Modified` 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的` Last-Modified` 会在 `response heade`r 返回，并在下次请求之前更新本地缓存的 `Last-Modified`，下次请求时，`If-Modified-Since`会启用更新后的 `Last-Modified`。
- `Etag/If-None-Match`， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过` ETag`字段返回给浏览器，接收到 `If-None-Matc`h 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 `Last-Modified` 不一样的是，当服务器返回 `304 Not Modified` 的响应时，由于在服务器`上ETag` 重新计算过，`response header`中还会把这个 `ETag` 返回，即使这个 `ETag `跟之前的没有变化。

> HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。


#### 为什么要有 Etag

`HTTP1.1` 中 `Etag` 的出现主要是为了解决几个 `Last-Modified` 比较难解决的问题：

- 一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，`If-Modified-Since` 能检查到的粒度是秒级的，使用 `Etag` 就能够保证这种需求下客户端在 1 秒内能刷新 `N` 次 `cache。`
- 某些服务器不能精确的得到文件的最后修改时间。


### 优先级

```bash
 Cache-Control  > expires > Etag > Last-Modified
```

### 用户行为对缓存的影响

同一个文件 qq 、fire fox 浏览器会返回 `304 Not Nodified`，在请求头中不携带 `Expires/Cache-Control`； 而 `chrome` 和 `safari` 刷新的时候，会返回 2`00 from cache`， 没有真正发起请求，走强缓存。可见不同的浏览器反馈是不一致的，所以下面表格中"F5 刷新"时` Expires/Cache-Control` 会无效是存在一定争议的。

而 Ctrl + F5 强制刷新的时候，会暂时禁用强缓存和协商缓存。

|用户操作|	Expires/Cache-Control|	Last-Modied/Etag|
|---|---|---|
|地址栏回车|	有效|	有效|
|页面链接跳转|	有效|	有效|
|新开窗口|	有效|	有效|
|前进回退|	有效|	有效|
|F5 刷新|	无效(有争议，不同浏览器反馈不一致)|	有效|
|Ctrl+F5| 强制刷新|	无效	|无效|


### 如何设置强缓存和协商缓存

#### 后端服务器写入
```java
res.setHeader('max-age': '3600 public')
res.setHeader(etag: '5c20abbd-e2e8')
res.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)
```

#### NGINX配置

```bash
add_header Cache-Control "max-age=3600"
```

一般来说，通过 nginx 静态资源服务器，会默认给资源带上强缓存、协商缓存的 header 字段。

![NGINX](https://user-images.githubusercontent.com/11473889/57010188-fae2b380-6c2d-11e9-974e-6d2cb4eee219.png)


## 四种缓存的机制

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

### 1.Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。**Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。**

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### 2.Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 **一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。**

**那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？**
这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。

内存缓存中有一块重要的缓存资源是preloader相关指令（例如`<link rel="prefetch">`）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。

需要注意的事情是，**内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。**

### 3.Disk Cache


Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，**比之 Memory Cache 胜在容量和存储时效性上。**

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。

**浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**
关于这点，网上说法不一，不过以下观点比较靠得住：

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

### 4.Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，**它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及.

- 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差
- 可以推送 no-cache 和 no-store 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 你可以给其他域名推送资源

如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。

那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，**通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。**
