[TOC]
# 浏览器的渲染流程

> 1. 处理 HTML 并构建 DOM 树
> 2. 处理 CSS 构建 CSSOM 树
> 3. 将 DOM 与 CSSOM 合并成一个渲染树
> 4. 计算布局
> 5. 图层分层
> 6. 绘制并分块
> 7. 光栅化

## 浏览器的进程

浏览器的进程目前一般分为五种（以 chrome 为例)，渲染流程是其中开发接触频率最多的。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎和 JavaScript 引擎都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 从 HTML 到 DOM

1. 浏览器进程->渲染进程

浏览器通过网络进程拿到数据后，找到对应的渲染进程，并把数据传输进去。这时候渲染进程拿到了最原始的数据，但只是字节数据，尚不能被浏览器使用。

2. 字节数据转为字符

根据字符编码将字节数据解码成字符数据,这时候的数据就是我们敲键盘敲下来的代码了。

3. 字符进一步转化为标记（token）

标记就是让编写的 html 代码成为浏览器引擎能解析的语言。我们可以把标记理解为包含了某个 Html 标签信息一种数据结构。

4. 节点

这一步，解析器把标记转化为节点，也就是 DOM 对象里面的各个独立的实体，但还不是最终的状态，因为这些独立个体还没建立起联系

5. 形成 DOM 树

解析器把各个节点连接起来，整个结构就像一个树一样，也就是我们所说的 DOM 树总算形成。在这个树结构中，各个节点的父子兄弟关系就能被进程解析了。

![](./images/1732000000503_image.png)

## 构建 CSS 树

1. 从 html 中获取 css 文件并解析

当解析 DOM 树过程中遇到这个 CSS 文件，就会形成阻塞然后去获取并解析 CSS 文件。

```html
<!DOCTYPE html>
<html>
  <head>
    <link
      rel="stylesheet"
      type="text/css"
      media="screen"
      href="test.css"
    />
  </head>
  <body>
    test
  </body>
</html>
```

同样的解析机制，浏览器接收的还是 css 文件数据的原始字节，然后跟构建 DOM 树一样的流程去把字节转换为字符-标记-节点，最后形成树结构，也就是我们常谈的 CSSOM 或 CSS 树。

由于浏览器也无法解析纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时， 会将 CSS 文本转换为浏览器可以理解的结构，styleSheets。
![](./images/1732000731519_image.png)
但 CSS 树相比 DOM 树多了以下对 CSS 的处理：

#### 1. 标准化样式表中的属性值
   CSS 文本中存在很多属性值，例如 1em、blue、bold 等属性值不容易被渲染引擎 识别，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个 过程就是属性值标准化。

标准化属性值：
![](./images/1732000768155_image.png)

#### 2. 计算 DOM 数中每个节点的具体样式
   样式属性标准化后，还要计算 DOM 树中每个节点的样式属性，其中涉及 CSS 的继承规则 和层叠规则。

**CSS 继承**
CSS 继承就是每个 DOM 节点都包含了父节点的样式。例如：
![](./images/1732000882054_image.png)

可了解到，例如 body 节点的 font-size 的属性，body 节点下的所以子节点 都继承了。

另可通过“开发者工具”->Element,查看“style”标签：
![](./images/element-console.png)

通过分析，我们可以选择对应第一区域对应的元素，可查询改元素的样式(对应区域 2 中)； 并且可通过区域 3 可查看对应样式的来源心情，其中，UserAgent 样式，是浏览器 提供的一组默认样式，如果不修改任何样式，默认使用的是 UserAgent 样式

**CSS 层叠**
层叠是 CSS 的一个基本特征，它定义了如何合并来自多个源的属性值的算法。 CSS 的全称“层叠样式表”即强调了这点。

![](./images/image1.png)

> 样式计算阶段的目的就是为了计算出DOM节点中每个元素的具体样式，在计算过程 中遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式， 并被保存在ComputdStyle的结构内。

## 布局阶段

有了DOM树和DOM树中元素的样式，接下来还需要计算出DOM树中可见元素的几何位置， 这个计算过程叫布局。

Chrome在布局阶段需完成两个任务：创建布局树和布局计算。

### 1、创建布局树

其中DOM树中还包含很多不可见的元素，例如head标签，display为none属性的元素等。所以在 显示之前，需要额外构建一颗只包含可见元素的布局树。


![](./images/image.png)

### 2、布局计算

有了完整的布局树后，则需计算布局树节点的坐标位置。而HTML采用的是 流式布局模型，基本原则是按照元素在顺序遍历过程中依次从左到右、从上 到下的排序方式确定位置区域。当然还存在一些特殊的布局方式，例如通过position 属性的定位布局和float实现的浮动布局等。


## 阶段总结

我们了解到了渲染流程的前三个阶段为：**DOM生成**、**样式计算**和**布局**：

浏览器不能直接解析HTML数据，所以第一步需要将其转换为DOM树结构；
生成DOM树后，接着根据CSS样式表，计算DOM树所以节点的样式；
最后根据计算DOM元素的布局信息，保存在布局树中。

## 分层

因为页面中有很多复杂的效果，如3D变换、页面滚动，z-index等，为了实现 这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的 图层树(LayerTree)。其类似于PS的图层概念。

**浏览器的页面实际上被分层了很多图层，这些图层叠加后合成最终的页面。**

布局树和图层树的关系：

![](./images/image3.png)


通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的 层，那么这个节点就从属于父节点的图层。**例如上图的span就从属于父节点图层。

通常满足其下两点中的任意一点即可被提升为单独的一个图层：

**第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**

页面是个二维页面，但是层叠上下文能够让HTML元素具有三维概念，这些HTML元素按照 自身属性的优先级分布在垂直于这个二维页面的z轴上。

层叠上下文示意图：

![](./images/image4.png)

例如图中的，定位属性的元素、定义透明度属性的元素、使用CSS滤镜的元素 等都具有层叠上下文属性。

**第二点，需要剪裁的地方也会被创建为图层。**

```html

<style>
      div {
            width: 200;
            height: 200;
            overflow:auto;
            background: gray;
        } 
</style>
<body>
    <div >
        <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
        <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
        <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
    </div>
</body>
```

例如所示，文字所显示的区域超过了200*200的显示范围时就产生了剪裁，渲染引擎会把剪裁文字内容 的一部分用于显示在div区域。

出现这种剪裁情况下，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会 被提升为单独的层。

## 图层绘制

在完成图层树的构建后，渲染引擎会对图层树中的每个图层进行绘制，渲染引擎会把每个图层的 绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

![](./images/image5.png)


绘制列表中的指令其实就是让其执行一个简单的绘制操作，而每个原生的背景、边框等都需要单独 的指令绘制，通过几条绘制指令来实现绘制一个元素。

## 栅格化操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上绘制操作是由渲染引擎 中的合成线程来完成的。

渲染进程中的合成线程和主线程：

![](./images/image6.png)

当图层的绘制列表准备完成后，主线程会把该绘制列表提交给合成线程。

通常一个页面很大，而用户有时只能看到其中一部分，所以屏幕上页面的可见区域叫视口(ViewPort)。

这种情况下，要绘制出所有图层内容的话产生的开销太多，所以，合成线程会将图层划分为图块(title)， 这些图片的大小通常是256256或512512。

图层图块示意图：

![](./images/image7.png)

合成线程会按照视口附件的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。 所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程 维护了一个栅格化的线程池，所以的图块栅格化都是在线程池内执行的。

合成线程提交图块给栅格化线程池：

![](./images/1732001797217_image.png)

通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化或者 GPU栅格化，渲染进程会把生成图块的指令发送给GPU进程，然后在 GPU进程中执行生成图块的位图，生成的位图被保存在GPU内存中。

GPU栅格化：

![](./images/1732001816607_image.png)

## 合成和显示

所有图块都被栅格化，合成线程就会生成一个绘制图块的命令，“DrawQuad”，然后 将该命令提交给浏览器进程。

浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据 DrawQuad命令将其页面内容绘制到内存中，最后将内存显示在屏幕上。
