import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,b as r,d as i,w as l,r as s,o as p,e as x}from"./app-BcBpUkWz.js";const c={};function h(d,e){const t=s("RouteLink");return p(),n("div",null,[a("p",null,[i(t,{to:"/rear-end/JavaWeb/6-JWT.html"},{default:l(()=>e[0]||(e[0]=[x("参考 JWT 认证")])),_:1})]),e[1]||(e[1]=r('<h3 id="认证流程" tabindex="-1"><a class="header-anchor" href="#认证流程"><span>认证流程</span></a></h3><p>Step-1：用户端发起登录请求，发账号密码给服务端</p><p>Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法</p><ol><li>认证成功 服务端将创建一个 JWT 字符串响应发送给前端 （response:{token:xxx.xxx.xxx}）<br> 1.1 前端拿到 JWT 的 token，如果想要数据，就分割第二段 xxx ，第二段是数据的载体，拿到后进行 Base64 解码就可以了<br> 1.2 后续前端发的所有请求，在请求头中都会自动带上 {Authorization:token}，把 token 传送给后端<br> 1.3 后端拿到 token 后会进行 token 解密，检查 signature 进行放行，如果 signature 没有被修改，就会进行放行</li><li>认证失败 发送用户鉴权失败信息给前端</li></ol><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><h4 id="优势" tabindex="-1"><a class="header-anchor" href="#优势"><span>优势</span></a></h4><ul><li>无状态性，token 本身包含了所有必要的用户信息或授权信息，服务器无需存储关于用户会话的状态信息，降低了服务器内存压力。</li><li>跨域支持，由于token可以轻松附加在HTTP请求头中（如Authorization头），不受同源策略限制，因此非常适合跨域应用场景。</li><li>通过将token作为请求的一部分，而不是依赖于cookie，可以在一定程度上降低 CSRF（跨站请求伪造）攻击的风险.</li><li>安全性高，使用非对称加密算法颁发的token 可以保证即使在网络上传输也不会泄漏敏感信息，只有拥有私钥的服务端才能解密并验证token的有效性。</li><li>灵活性高，token可以自由定制，包含自定义的有效载荷信息，并且可以指定过期时间，便于实现细粒度的权限控制。</li></ul><h4 id="劣势" tabindex="-1"><a class="header-anchor" href="#劣势"><span>劣势</span></a></h4><ul><li>安全性风险，如果token没有正确实现安全措施，例如未加密存储或传输过程未受到保护，那么token被盗用可能导致安全问题。</li><li>因为token是无状态的，如果用户注销或权限发生变化，如果不实时更新或撤销token，服务器无法立即终止旧token的有效性，只能等待token过期。</li><li>存储与刷新频繁，token的存储需要妥善管理，如若存放在客户端且未加密，易遭窃取；同时，长生命周期的token需要刷新机制来延长用户会话，否则可能导致用户频繁重新登录。</li></ul>',9))])}const u=o(c,[["render",h]]),g=JSON.parse('{"path":"/web/storage/token.html","title":"Token","lang":"zh-CN","frontmatter":{"title":"Token","tag":["storage","JWT"],"star":true,"description":"认证流程 Step-1：用户端发起登录请求，发账号密码给服务端 Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法 认证成功 服务端将创建一个 JWT 字符串响应发送给前端 （response:{token:xxx.xxx.xxx}） 1.1 前端拿到 JWT 的 token，如果想要数据，就分割第二段 xxx ，第二段是数据的载体，拿到后进...","head":[["meta",{"property":"og:url","content":"https://soft-vault.com/what-tools-blog/web/storage/token.html"}],["meta",{"property":"og:site_name","content":"Night.Soul"}],["meta",{"property":"og:title","content":"Token"}],["meta",{"property":"og:description","content":"认证流程 Step-1：用户端发起登录请求，发账号密码给服务端 Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法 认证成功 服务端将创建一个 JWT 字符串响应发送给前端 （response:{token:xxx.xxx.xxx}） 1.1 前端拿到 JWT 的 token，如果想要数据，就分割第二段 xxx ，第二段是数据的载体，拿到后进..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-24T14:33:33.000Z"}],["meta",{"property":"article:tag","content":"storage"}],["meta",{"property":"article:tag","content":"JWT"}],["meta",{"property":"article:modified_time","content":"2025-03-24T14:33:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Token\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-24T14:33:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Night.Soul\\",\\"url\\":\\"https://github.com/NightSquirrl\\"}]}"]]},"headers":[{"level":3,"title":"认证流程","slug":"认证流程","link":"#认证流程","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]}],"git":{"createdTime":1742826813000,"updatedTime":1742826813000,"contributors":[{"name":"nightsquirrl","username":"nightsquirrl","email":"“w1083670160@163.com”","commits":1,"url":"https://github.com/nightsquirrl"}]},"readingTime":{"minutes":2.12,"words":635},"filePathRelative":"web/storage/token.md","localizedDate":"2025年3月24日","excerpt":"<p><a href=\\"/what-tools-blog/rear-end/JavaWeb/6-JWT.html\\" target=\\"_blank\\">参考 JWT 认证</a></p>\\n<h3>认证流程</h3>\\n<p>Step-1：用户端发起登录请求，发账号密码给服务端</p>\\n<p>Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法</p>\\n<ol>\\n<li>认证成功 服务端将创建一个 JWT 字符串响应发送给前端 （response:{token:xxx.xxx.xxx}）<br>\\n1.1 前端拿到 JWT 的 token，如果想要数据，就分割第二段 xxx ，第二段是数据的载体，拿到后进行 Base64 解码就可以了<br>\\n1.2 后续前端发的所有请求，在请求头中都会自动带上 {Authorization:token}，把 token 传送给后端<br>\\n1.3 后端拿到 token 后会进行 token 解密，检查 signature 进行放行，如果 signature 没有被修改，就会进行放行</li>\\n<li>认证失败 发送用户鉴权失败信息给前端</li>\\n</ol>","autoDesc":true}');export{u as comp,g as data};
