import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as t,o as i}from"./app-BcBpUkWz.js";const r={};function n(a,e){return i(),s("div",null,e[0]||(e[0]=[t('<p>前言:<br> 一般来说,session 的概念存在于后端服务器中,前端基本不需要单独的操作. 知道这一句话也就足够了,再看看优缺点</p><h3 id="认证流程" tabindex="-1"><a class="header-anchor" href="#认证流程"><span>认证流程</span></a></h3><p>Step-1：用户端发起登录请求，发账号密码给服务端</p><p>Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法</p><p>认证成功 <mark>服务端</mark>往 <code>session</code> 中存入当前用户信息 ，并响应前端请求（response-header:set-cookie(sessionid)）<br> 后端响应前端时会带上 set-cookie 属性，同时将当前 <code>session</code> 的唯一ID，放入属性中<br> 前端拿到 <code>session</code> ID 后会自动存入到 cookie 中<br> 后续前端每次请求，都会在 request header 的 cookie 中带上唯一的 <code>session</code> ID<br> 后端拿到唯一的 <code>session</code> ID 就可映射当前 <code>session</code> ID 对应的用户信息，以维持用户登录状态<br> 认证失败 发送用户鉴权失败信息给前端</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><p>后端只要往 Session 里面存入用户信息，不仅限于字符串，对象也可以（容量大）<br> 获取 Session 信息方便，Session ID 唯一映射<br> Web 服务器端（如tomcat），会在响应头存入 set-cookie 属性，以及当前 session 唯一ID<br> 浏览器检测有响应有set-cookie 属性，会自动存入 cookie 中，前端不需要手动去调用 setCookie() 方法<br> 下一次前端请求会自动带上 cookie 发送给后端<br> 存储在服务器端，安全性大大提高，避免篡改风险</p><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><p>占用服务器资源<br> 扩展性差 （分布式集群）<br> 需要依赖 cookie<br> 跨域限制<br> 小程序不支持 cookie</p><h4 id="扩展性差" tabindex="-1"><a class="header-anchor" href="#扩展性差"><span>扩展性差</span></a></h4><blockquote><p>针对后端的集群部署，需要在后端进行 session 的持久化的缺点</p></blockquote><ol><li>当后端压力大时，我们可能对后端进行集群部署，如 192.168.1.101:8001，192.168.1.102:8002，192.168.1.103:8003</li><li>此时前端发起登录请求，我们往 session 存入当前 A用户 信息，只会在一台服务器中存储，如 192.168.1.101:8001</li><li>其他服务器是没有 A用户 的登录信息的</li><li>集群之后的 负载均衡 可能下一次请求就会打到其他服务器上</li><li>判定用户没有登录</li></ol><blockquote><p>针对跨域的缺点</p></blockquote><ol><li>在当下移动端盛行情况下，我们可能有 网页端 192.168.1.102:8080，移动端 192.168.1.102:8090，小程序端，Android端，Mac端等等 192.168.1.102:XXXX</li><li>这些端都会有各自端口和域名，这个时候前端再次请求后端，就会发生跨域问题</li><li>跨域情况下 cookie 默认是无法进行传递的</li><li>解决思路是 后端设置允许跨域，前端单独设置允许跨越的 cookie 传递 （跨域传递cookie 十分麻烦）</li></ol>',14)]))}const p=o(r,[["render",n]]),d=JSON.parse('{"path":"/web/storage/session.html","title":"Session","lang":"zh-CN","frontmatter":{"title":"Session","tag":["storage"],"star":true,"description":"前言: 一般来说,session 的概念存在于后端服务器中,前端基本不需要单独的操作. 知道这一句话也就足够了,再看看优缺点 认证流程 Step-1：用户端发起登录请求，发账号密码给服务端 Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法 认证成功 服务端往 session 中存入当前用户信息 ，并响应前端请求（response-heade...","head":[["meta",{"property":"og:url","content":"https://soft-vault.com/what-tools-blog/web/storage/session.html"}],["meta",{"property":"og:site_name","content":"Night.Soul"}],["meta",{"property":"og:title","content":"Session"}],["meta",{"property":"og:description","content":"前言: 一般来说,session 的概念存在于后端服务器中,前端基本不需要单独的操作. 知道这一句话也就足够了,再看看优缺点 认证流程 Step-1：用户端发起登录请求，发账号密码给服务端 Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法 认证成功 服务端往 session 中存入当前用户信息 ，并响应前端请求（response-heade..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-24T14:33:33.000Z"}],["meta",{"property":"article:tag","content":"storage"}],["meta",{"property":"article:modified_time","content":"2025-03-24T14:33:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Session\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-24T14:33:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Night.Soul\\",\\"url\\":\\"https://github.com/NightSquirrl\\"}]}"]]},"headers":[{"level":3,"title":"认证流程","slug":"认证流程","link":"#认证流程","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}],"git":{"createdTime":1742826813000,"updatedTime":1742826813000,"contributors":[{"name":"nightsquirrl","username":"nightsquirrl","email":"“w1083670160@163.com”","commits":1,"url":"https://github.com/nightsquirrl"}]},"readingTime":{"minutes":2.36,"words":707},"filePathRelative":"web/storage/session.md","localizedDate":"2025年3月24日","excerpt":"<p>前言:<br>\\n一般来说,session 的概念存在于后端服务器中,前端基本不需要单独的操作. 知道这一句话也就足够了,再看看优缺点</p>\\n<h3>认证流程</h3>\\n<p>Step-1：用户端发起登录请求，发账号密码给服务端</p>\\n<p>Step-2：服务端进行鉴权认证，判断用户名密码是否正确合法</p>\\n<p>认证成功 <mark>服务端</mark>往 <code>session</code> 中存入当前用户信息 ，并响应前端请求（response-header:set-cookie(sessionid)）<br>\\n后端响应前端时会带上 set-cookie 属性，同时将当前 <code>session</code> 的唯一ID，放入属性中<br>\\n前端拿到 <code>session</code> ID 后会自动存入到 cookie 中<br>\\n后续前端每次请求，都会在 request header 的 cookie 中带上唯一的 <code>session</code> ID<br>\\n后端拿到唯一的 <code>session</code> ID 就可映射当前 <code>session</code> ID 对应的用户信息，以维持用户登录状态<br>\\n认证失败 发送用户鉴权失败信息给前端</p>","autoDesc":true}');export{p as comp,d as data};
